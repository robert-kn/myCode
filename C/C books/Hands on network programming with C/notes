Network programming is a fun topic, but it's also a very deep one; a lot is going on at many levels. Some programming languages hide these abstractions. In Python for example, you can download an entire web page using only one line of code. This isn't the case in C! In C, if you want to download a web page, you have to know how everything works. You need to know sockets, you need to know Transfer Control Protocol (TCP), and you need to know HTTP. In C network programming, nothing is hidden.

C is a great language to learn network programming in. This is not only because we get to see all the details, but also because the popular operating systems all use kernels written in C. No other language gives you the same first-class access as C does. In C, everything is under your control – you can lay out your data structures exactly how you want, manage memory precisely as you please, and even shoot yourself in the foot just the way you want.

There is a lot of C networking code that is done wrong. Internet tutorials about C sockets often use deprecated functions and ignore memory safety completely. When it comes to network programming, you can't take the it works so it's good enough programming-by-coincidence approach. You have to use reasoning.

source code form the book can be found here https://github.com/codeplea/Hands-On-Network-Programming-with-C

chapter 1

The use of the C programming language is ubiquitous. Almost every network stack is programmed in C. This is true for Windows, Linux, and macOS. If your mobile phone uses Android or iOS, then even though the apps for these were programmed in a different language (Java and Objective C), the kernel and networking code was written in C. It is very likely that the network routers that your internet data goes through are programmed in C. Even if the user interface and higher-level functions of your modem or router are programmed in another language, the networking drivers are still probably implemented in C.

Networking encompasses concerns at many different abstraction levels. The concerns your web browser has with formatting a web page are much different than the concerns your router has with forwarding network packets. For this reason, it is useful to have a theoretical model that helps us to understand communications at these different levels of abstraction. Let's look at these models now.

OSI layer model

It's clear that if all of the disparate devices composing the internet are going to communicate seamlessly, there must be agreed-upon standards that define their communications. These standards are called protocols. Protocols define everything from the voltage levels on an Ethernet cable to how a JPEG image is compressed on a web page. It's clear that, when we talk about the voltage on an Ethernet cable, we are at a much different level of abstraction compared to talking about the JPEG image format. If you're programming a website, you don't want to think about Ethernet cables or Wi-Fi frequencies. Likewise, if you're programming an internet router, you don't want to have to worry about how JPEG images are compressed. For this reason, we break the problem down into many smaller pieces.

One common method of breaking down the problem is to place levels of concern into layers. Each layer then provides services for the layer on top of it, and each upper layer can rely on the layers underneath it without concern for how they work.

The most popular layer system for networking is called the Open Systems Interconnection model (OSI model). It was standardized in 1977 and is published as ISO 7498. It has seven layers:

Let's understand these layers one by one:

Physical (1): This is the level of physical communication in the real world.  At this level, we have specifications for things such as the voltage levels on an Ethernet cable, the radio frequency of Wi-Fi etc
Data Link (2): This level builds on the physical layer. It deals with protocols for directly communicating between two nodes.
Network layer (3): The network layer provides the methods to transmit data sequences (called packets) between nodes in different networks.
Transport layer (4): At this layer, we have methods to reliably deliver variable length data between hosts. These methods deal with splitting up data, recombining it, ensuring data arrives in order, and so on. TCP and UDP protocols are in this layer.
Session layer (5): This layer builds on the transport layer by adding methods to establish, checkpoint, suspend, resume, and terminate dialogs.
Presentation layer (6): This is the lowest layer at which data structure and presentation for an application are defined. Concerns such as data encoding, serialization, and encryption are handled here.
Application layer (7): The applications that the user interfaces with (for example, web browsers and email clients) exist here. These applications make use of the services provided by the six lower layers.

In the OSI model, an application, such as a web browser, exists in the application layer (layer 7). A protocol from this layer, such as HTTP used to transmit web pages, doesn't have to concern itself with how the data is being transmitted. It can rely on services provided by the layer underneath it to effectively transmit data. see diagram

It should be noted that chunks of data are often referred to by different names depending on the OSI layer they're on. A data unit on layer 2 is called a frame, since layer 2 is responsible for framing messages. A data unit on layer 3 is referred to as a packet, while a data unit on layer 4 is a segment if it is part of a TCP connection or a datagram if it is a UDP message.

In this book, we often use the term packet as a generic term to refer to a data unit on any layer. However, segment will only be used in the context of a TCP connection, and datagram will only refer to UDP datagrams.

The OSI model doesn't fit precisely with the common protocols in use today. However, it is still a handy model to explain networking concerns, and it is still in widespread use for that purpose today.

TCP/IP layer model

The TCP/IP protocol suite is the most common network communication model in use today. The TCP/IP reference model differs a bit from the OSI model, as it has only four layers instead of seven.

The following diagram illustrates how the four layers of the TCP/IP model line up to the seven layers of the OSI model: see diagram

Notably, the TCP/IP model doesn't match up exactly with the layers in the OSI model. That's OK. In both models, the same functions are performed; they are just divided differently.

The four layers of the TCP/IP model are as follows:

Network Access layer (1): On this layer, physical connections and data framing happen. Sending an Ethernet or Wi-Fi packet are examples of layer 1 concerns.

Internet layer (2): This layer deals with the concerns of addressing packets and routing them over multiple interconnection networks. It's at this layer that an IP address is defined.

Host-to-Host layer (3): The host-to-host layer provides two protocols, TCP and UDP, which we will discuss in the next few chapters. These protocols address concerns such as data order, data segmentation, network congestion, and error correction.

Process/Application layer (4): The process/application layer is where protocols such as HTTP, SMTP, and FTP are implemented. Most of the programs that feature in this book could be considered to take place on this layer while consuming functionality provided by our operating system's implementation of the lower layers.

Regardless of your chosen abstraction model, real-world protocols do work at many levels. Lower levels are responsible for handling data for the higher levels. These lower-level data structures must, therefore, encapsulate data from the higher levels.

Data encapsulation

The advantage of these abstractions is that, when programming an application, we only need to consider the highest-level protocol. For example, a web browser needs only to implement the protocols dealing specifically with websites—HTTP, HTML, CSS, and so on. It does not need to bother with implementing TCP/IP, and it certainly doesn't have to understand how an Ethernet or Wi-Fi packet is encoded. It can rely on ready-made implementations of the lower layers for these tasks. These implementations are provided by the operating system (for example, Windows, Linux, and macOS).

When communicating over a network, data must be processed down through the layers at the sender and up again through the layers at the receiver. For example, if we have a web server, Host A, which is transmitting a web page to the receiver, Host B, it may look like this: see diagram

The web page contains a few paragraphs of text, but the web server doesn't only send the text by itself. For the text to be rendered correctly, it must be encoded in an HTML structure: see diagram

In some cases, the text is already preformatted into HTML and saved that way but, in this example, we are considering a web application that dynamically generates the HTML, which is the most common paradigm for dynamic web pages. As the text cannot be transmitted directly, neither can the HTML. It instead must be transmitted as part of an HTTP response. The web server does this by applying the appropriate HTTP response header to the HTML: see diagram

The HTTP is transmitted as part of a TCP session. This isn't done explicitly by the web server, but is taken care of by the operating system's TCP/IP stack: see diagram

The TCP packet is routed by an IP packet: see diagram

This is transmitted over the wire in an Ethernet packet (or another protocol): see diagram

Luckily for us, the lower-level concerns are handled automatically when we use the socket APIs for network programming. It is still useful to know what happens behind the scenes. Without this knowledge, dealing with failures or optimizing for performance is difficult if not impossible.

With some of the theory out of the way, let's dive into the actual protocols powering modern networking.

Internet Protocol

Twenty years ago, there were many competing networking protocols. Today, one protocol is overwhelmingly common—the Internet Protocol. It comes in two versions—IPv4 and IPv6. IPv4 is completely ubiquitous and deployed everywhere. If you're deploying network code today, you must support IPv4 or risk that a significant portion of your users won't be able to connect.

IPv4 uses 32-bit addresses, which limits it to addressing no more than 2^(32) or 4,294,967,296 systems. However, these 4.3 billion addresses were not initially assigned efficiently, and now many Internet Service Providers (ISPs) are forced to ration IPv4 addresses.

IPv6 was designed to replace IPv4 and has been standardized by the Internet Engineering Task Force (IETF) since 1998. It uses a 128-bit address, which allows it to address a theoretical 2^(128) = 340,282,366,920,938,463,463,374,607,431,768,211,456, or about a 3.4 x 10^(38) addresses.

Today, every major desktop and smartphone operating system supports both IPv4 and IPv6 in what is called a dual-stack configuration. However, many applications, servers, and networks are still only configured to use IPv4. From a practical standpoint, this means that you need to support IPv4 in order to access much of the internet. However, you should also support IPv6 to be future-proof and to help the world to transition away from IPv4.

IPv4 addresses are 32 bits long. They are commonly divided into four 8-bit sections. Each section is displayed as a decimal number between 0 and 255 inclusive and is delineated by a period.

Here are some examples of IPv4 addresses:

0.0.0.0, 127.0.0.1, 10.0.0.0, 172.16.0.5, 192.168.0.1, 192.168.50.1, 255.255.255.255

A special address, called the loopback address, is reserved at 127.0.0.1. This address essentially means establish a connection to myself. Operating systems short-circuit this address so that packets sent to it never enter the network but instead stay local on the originating system.

IPv4 reserves some address ranges for private use. If you're using IPv4 through a router/NAT, then you are likely using an IP address in one of these ranges. These reserved private ranges are as follows:

10.0.0.0 to 10.255.255.255
172.16.0.0 to 172.31.255.255
192.168.0.0 to 192.168.255.255

The concept of IP address ranges is a useful one that comes up many times in networking. It's probably not surprising then that there is a shorthand notation for writing them. Using Classless Inter-Domain Routing (CIDR) notation, we can write the three previous address ranges as follows:

10.0.0.0/8
172.16.0.0/12
192.168.0.0/16

CIDR notation works by specifying the number of bits that are fixed. For example, 10.0.0.0/8 specifies that the first eight bits of the 10.0.0.0 address are fixed, the first eight bits being just the first 10. part; the remaining 0.0.0 part of the address can be anything and still be on the 10.0.0.0/8 block. Therefore, 10.0.0.0/8 encompasses 10.0.0.0 through 10.255.255.255.

IPv6 addresses are 128 bits long. They are written as eight groups of four hexadecimal characters delineated by colons. A hexadecimal character can be from 0-9 or from a-f. Here are some examples of IPv6 addresses:

0000:0000:0000:0000:0000:0000:0000:0001
2001:0db8:0000:0000:0000:ff00:0042:8329
fe80:0000:0000:0000:75f4:ac69:5fa7:67f9
ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff

Note that the standard is to use lowercase letters in IPv6 addresses. This is in contrast to many other uses of hexadecimal in computers.

There are a couple of rules for shortening IPv6 addresses to make them easier. Rule 1 allows for the leading zeros in each section to be omitted (for example, 0db8 = db8). Rule 2 allows for consecutive sections of zeros to be replaced with a double colon (::). Rule 2 may only be used once in each address; otherwise, the address would be ambiguous.

Applying both rules, the preceding addresses can be shortened as follows:

::1
2001:db8::ff00:42:8329
fe80::75f4:ac69:5fa7:67f9
ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff

Like IPv4, IPv6 also has a loopback address. It is ::1.

Dual-stack implementations also recognize a special class of IPv6 address that map directly to an IPv4 address. These reserved addresses start with 80 zero bits, and then by 16 one bits, followed by the 32-bit IPv4 address. Using CIDR notation, this block of address is ::ffff:0:0/96.

These mapped addresses are commonly written with the first 96 bits in IPv6 format followed by the remaining 32 bits in IPv4 format. Here are some examples:

IPv6 Address                     Mapped IPv4 Address
::ffff:10.0.0.0                  10.0.0.0
::ffff:172.16.0.5                172.16.0.5
::ffff:192.168.0.1               192.168.0.1
::ffff:192.168.50.1              192.168.50.1

You may also run into IPv6 site-local addresses. These site-local addresses are in the fec0::/10 range and are for use on private local networks. Site-local addresses have now been deprecated and should not be used for new networks, but many existing implementations still use them.

Another address type that you should be familiar with are link-local addresses. Link-local addresses are usable only on the local link. Routers never forward packets from these addresses. They are useful for a system to accesses auto-configuration functions before having an assigned IP address. Link-local addresses are in the IPv4 169.254.0.0/16 address block or the IPv6 fe80::/10 address block.

It should be noted the IPv6 introduces many additional features over IPv4 besides just a greatly expanded address range. IPv6 addresses have new attributes, such as scope and lifetime, and it is normal for IPv6 network interfaces to have multiple IPv6 addresses. IPv6 addresses are used and managed differently than IPv4 addresses.

Domain names

The Internet Protocol can only route packets to an IP address, not a name. So, if you try to connect to a website, such as example.com, your system must first resolve that domain name, example.com, into an IP address for the server that hosts that website.

This is done by connecting to a Domain Name System (DNS) server. You connect to a domain name server by knowing in advance its IP address. The IP address for a domain name server is usually assigned by your ISP.

Many other domain name servers are made publicly available by different organizations.

To resolve a hostname, your computer sends a UDP message to your domain name server and asks it for an AAAA-type record for the domain you're trying to resolve. If this record exists, an IPv6 address is returned. You can then connect to a server at that address to load the website. If no AAAA record exists, then your computer queries the server again, but asks for an A record. If this record exists, you will receive an IPv4 address for the server. In many cases, a site will publish an A record and an AAAA record that route to the same server.

It is also possible, and common, for multiple records of the same type to exist, each pointing to a different address. This is useful for redundancy in the case where multiple servers can provide the same service.

Internet routing

The internet today has an estimated 20 billion devices connected. When you make a connection over the internet, your data first transmits to your local router. From there, it is transmitted to another router, which is connected to another router, and so on. Eventually, your data reaches a router that is connected to the receiving device, at which point, the data has reached its destination: see diagram

Imagine that each router in the preceding diagram is connected to tens, hundreds, or even thousands of other routers and systems. It's an amazing feat that IP can discover the correct path and deliver traffic seamlessly.

Windows includes a utility, tracert, which lists the routers between your system and the destination system. see diagram

The IP addresses are usually listed for many of the intermediate routers, but a few sometimes miss with the 'Request timed out message'. This usually means that the system in question doesn't support the part of the Internet Control Message Protocol (ICMP) protocol needed. It's not unusual to see a few such systems when running tracert.

In Unix-based systems, the utility to trace routes is called traceroute. The information obtained is essentially the same.

Sometimes, when IP packets are transferred between networks, their addresses must be translated. This is especially common when using IPv4. Let's look at the mechanism for this next.

Local networks and address translation

It's common for households and organizations to have small Local Area Networks (LANs). As mentioned previously, there are IPv4 addresses ranges reserved for use in these small local networks. 

These reserved private ranges are as follows:
10.0.0.0 to 10.255.255.255
172.16.0.0 to 172.31.255.255
192.168.0.0 to 192.168.255.255

When a packet originates from a device on an IPv4 local network, it must undergo Network Address Translation (NAT) before being routed on the internet. A router that implements NAT remembers which local address a connection is established from.

The devices on the same LAN can directly address one another by their local address. However, any traffic communicated to the internet must undergo address translation by the router. The router does this by modifying the source IP address from the original private LAN IP address to its public internet IP address: see diagram

Likewise, when the router receives the return communication, it must modify the destination address from its public IP to the private IP of the original sender. It knows the private IP address because it was stored in memory after the first outgoing packet: see diagram

Network address translation can be more complicated than it first appears. In addition to modifying the source IP address in the packet, it must also update the checksums in the packet. Otherwise, the packet would be detected as containing errors and discarded by the next router. The NAT router must also remember which private IP address sent the packet in order to route the reply. Without remembering the translation address, the NAT router wouldn't know where to send the reply to on the private network.

NATs will also modify the packet data in some cases. For example, in the File Transfer Protocol (FTP), some connection information is sent as part of the packet's data. In these cases, the NAT router will look at the packet's data in order to know how to forward future incoming packets. IPv6 largely avoids the need for NAT, as it is possible (and common) for each device to have its own publicly-addressable address.

You may be wondering how a router knows whether a message is locally deliverable or whether it must be forwarded. This is done using a netmask, subnet mask, or CIDR.

Subnetting and CIDR

IP addresses can be split into parts. The most significant bits are used to identify the network or subnetwork, and the least significant bits are used to identify the specific device on the network.

IPv4 traditionally uses a mask notation to identify the IP address parts. For example, consider a router on the 10.0.0.0 network with a subnet mask of 255.255.255.0. This router can take any incoming packet and perform a bitwise AND operation with the subnet mask to determine whether the packet belongs on the local subnet or needs to be forwarded on. For example, this router receives a packet to be delivered to 10.0.0.105. It does a bitwise AND operation on this address with the subnet mask of 255.255.255.0, which produces 10.0.0.0. That matches the subnet of the router, so the traffic is local. If, instead, we consider a packet destined for 10.0.15.22, the result of the bitwise AND with the subnet mask is 10.0.15.0. This address doesn't match the subnet the router is on, and so it must be forwarded.

IPv6 uses CIDR. Networks and subnetworks are specified using the CIDR notation we described earlier. For example, if the IPv6 subnet is /112, then the router knows that any address that matches on the first 112 bits is on the local subnet.

So far, we've covered only routing with one sender and one receiver. While this is the most common situation, let's consider alternative cases too.

Multicast, broadcast, and anycast

When a packet is routed from one sender to one receiver, it uses unicast addressing. This is the simplest and most common type of addressing. All of the protocols we deal with in this book use unicast addressing.

Broadcast addressing allows a single sender to address a packet to all recipients simultaneously. It is typically used to deliver a packet to every receiver on an entire subnet.

If a broadcast is a one-to-all communication, then multicast is a one-to-many communication. Multicast involves some group management, and a message is addressed and delivered to members of a group.

Anycast addressed packets are used to deliver a message to one recipient when you don't care who that recipient is. This is useful if you have several servers that provide the same functionality, and you simply want one of them (you don't care which) to handle your request.

IPv4 and lower network levels support local broadcast addressing. IPv4 provides some optional (but commonly implemented) support for multicasting. IPv6 mandates multicasting support while providing additional features over IPv4's multicasting. Though IPv6 is not considered to broadcast, its multicasting functionality can essentially emulate it.

It's worth noting that these alternative addressing methods don't generally work over the broader internet. Imagine if one peer was able to broadcast a packet to every connected internet device. It would be a mess!

If you can use IP multicasting on your local network, though, it is worthwhile to implement it. Sending one IP level multicast conserves bandwidth compared to sending the same unicast message multiple times.

However, multicasting is often done at the application level. That is, when the application wants to deliver the same message to several recipients, it sends the message multiple times – once to each recipient.

We've covered how messages are routed through a network. Now, let's see how a message knows which application is responsible for it once it arrives at a specific system.

Port numbers

An IP address alone isn't quite enough. We need port numbers. To return to the telephone analogy, if IP addresses are phone numbers, then port numbers are like phone extensions. Generally, an IP address gets a packet routed to a specific system, but a port number is used to route the packet to a specific application on that system.

For example, on your system, you may be running multiple web browsers, an email client, and a video-conferencing client. When your computer receives a TCP segment or UDP datagram, your operating system looks at the destination port number in that packet. That port number is used to look up which application should handle it.

Port numbers are stored as unsigned 16-bit integers. This means that they are between 0 and 65,535 inclusive.

Some port numbers for common protocols are as follows:

Port Number             Protocol
20, 21          TCP     File Transfer Protocol (FTP)
22              TCP     Secure Shell (SSH)
23              TCP     Telnet
25              TCP     Simple Mail Transfer Protocol (SMTP)
53              UDP     Domain Name System (DNS)
80              TCP     Hypertext Transfer Protocol (HTTP)
110             TCP     Post Office Protocol, Version 3 (POP3)
143             TCP     Internet Message Access Protocol(IMAP)
194             TCP     Internet Relay Chat (IRC)
443             TCP     HTTP over TLS/SSL (HTTPS)
993             TCP     IMAP over TLS/SSL (IMAPS)
995             TCP     POP3 over TLS/SSL (POP3S)

Each of these listed port numbers is assigned by the Internet Assigned Numbers Authority (IANA). They are responsible for the official assignments of port numbers for specific protocols. Unofficial port usage is very common for applications implementing custom protocols. In this case, the application should try to choose a port number that is not in common use to avoid conflict.

Clients and servers

In the telephone analogy, a call must be initiated first by one party. The initiating party dials the number for the receiving party, and the receiving party answers.
This is also a common paradigm in networking called the client-server model. In this model, a server listens for connections. The client, knowing the address and port number that the server is listening on, establishes the connection by sending the first packet.
For example, the web server at example.com listens on port 80 (HTTP) and port 443 (HTTPS). A web browser (client) must establish the connection by sending the first packet to the web server address and port.

Putting it together

A socket is one end-point of a communication link between systems. It's an abstraction in which your application can send and receive data over the network, in much the same way that your application can read and write to a file using a file handle.

An open socket is uniquely defined by a 5-tuple item consisting of the following:

Local IP address
Local port
Remote IP address
Remote port
Protocol (UDP or TCP)

This 5-tuple is important, as it is how your operating system knows which application is responsible for any packets received. For example, if you use two web browsers to establish two simultaneous connections to example.com on port 80, then your operating system keeps the connections separate by looking at the local IP address, local port, remote IP address, remote port, and protocol. In this case, the local IP addresses, remote IP addresses, remote port (80), and protocol (TCP) are identical.

The deciding factor then is the local port (also called the ephemeral port), which will have been chosen to be different by the operating system for connection. This 5-tuple is also important to understand how NAT works. A private network may have many systems accessing the same outside resource, and the router NAT must store this five tuple for each connection in order to know how to route received packets back into the private network.

What's your address?

You can find your IP address using the ipconfig command on Windows, or the ifconfig command on Unix-based systems (such as Linux and macOS).

On Unix-based systems, we use either the ifconfig or ip addr commands. The ifconfig command is the old way and is now deprecated on some systems. The ip addr command is the new way, but not all systems support it yet.

If you are behind a NAT, there is often no good way to know your public IP address. Usually, the only resort is to contact an internet server that provides an API that informs you of your IP address.

A few free and public APIs for this are as follows:

http://api.ipify.org/
http://icanhazip.com/
http://ifconfig.me/ip

Now that we've seen the built-in utilities for determining our local IP addresses, let's next look at how to accomplish this from C.

Listing network adapters from C

Sometimes, it is useful for your C programs to know what your local address is. For most of this book, we are able to write code that works both on Windows and Unix-based (Linux and macOS) systems. However, the API for listing local addresses is very different between systems. For this reason, we split this program into two: one for Windows and one for Unix-based systems.

We will address the Windows case first. Please see win_list.c program in Code-and-IAC/C/listing-network-adapters-windows

Now that we can list local IP addresses on Windows, let's consider the same task for Unix-based systems.

Listing network adapters on Linux and macOS: Listing local network addresses is somewhat easier on a Unix-based system, compared to Windows. See unix_list.c in Code-and-IAC/C/listing-network-adapters-linux-macos

questions:

What are the key differences between IPv4 and IPv6?

IPv4 only supports 4 billion unique addresses, and because they were allocated inefficiently, we are now running out. IPv6 supports 3.4 x 10^38 possible addresses. IPv6 provides many other improvements, but this is the one that affects our network programming directly.

Are the IP addresses given by the ipconfig and ifconfig commands the same IP addresses that a remote web server sees if you connect to it?

Sometimes, these addresses will match, but not always. If you're on a private IPv4 network, then your router likely performs network address translation. The remote web server then sees the translated address.
If you have a publicly routable IPv4 or IPv6 address, then the address seen by the remote web server will match those reported by ipconfig and ifconfig.

What is the IPv4 loopback address?

The IPv4 loopback address is 127.0.0.1, and it allows networked programs to communicate with each other while executing on the same machine.

What is the IPv6 loopback address?

The IPv6 loopback address is ::1. It works in the same way as the IPv4 loopback address.

How are domain names (for example, example.com) resolved into IP addresses?

DNS is used to resolve domain names into IP addresses. 

How can you find your public IP address?

The easiest way is to visit a website that reports it for you.

How does an operating system know which application is responsible for an incoming packet?

Each IP packet has a local address, remote address, local port number, remote port number, and protocol type. These five attributes are memorized by the operating system to determine which application should handle any given incoming packet.

----

chapter 2

what are sockets? a socket is one endpoint of a communication link between end systems (hosts). Your applications sends and receives all of its network data through a socket.

There are a few different socket application programming interfaces (APIs). The first were Berkeley sockets, which were released in 1983 with 4.3BSD Unix. The Berkeley socket API was widely successful and quickly evolved into a de facto standard. From there, it was adopted as a POSIX standard with little modification. The terms Berkeley sockets, BSD sockets, Unix sockets, and Portable Operating System Interface (POSIX) sockets are often used interchangeably.

If you're using Linux or macOS, then your operating system provides a proper implementation of Berkeley sockets.

Windows' socket API is called Winsock. It was created to be largely compatible with Berkeley sockets.

Historically, sockets were used for inter-process communication (IPC) as well as various network protocols. In this book, we use sockets only for communication with TCP and UDP.

Before we can use the socket API, we need to include the socket API header files. These files vary depending on whether we are using Berkeley sockets or Winsock. Additionally, Winsock requires initialization before use. It also requires that a cleanup function is called when we are finished. These initialization and cleanup steps are not used with Berkeley sockets.

We will use the C preprocessor to run the proper code on Windows compared to Berkeley socket systems. By using the preprocessor statement, #if defined(_WIN32), we can include code in our program that will only be compiled on Windows.

A complete program that includes the needed socket API headers for each platform and properly initializes Winsock on Windows can be found in Code-and-IAC/C/listing-network-adapters-all

Now that we've done the necessary setup to begin using the socket APIs, let's take a closer look at what we will be using these sockets for.

Two types of sockets

Sockets come in two basic types — connection-oriented and connectionless. These terms refer to types of protocols. Beginners sometimes get confused with the term connectionless. Of course, two systems communicating over a network are in some sense connected. Keep in mind that these terms are used with special meanings, which we will cover shortly, and should not imply that some protocols manage to send data without a connection.

The two protocols that are used today are Transmission Control Protocol (TCP) and User Datagram Protocol (UDP). TCP is a connection-oriented protocol, and UDP is a connectionless protocol.

The socket APIs also support other less-common or outdated protocols, which we do not cover in this book.

In a connectionless protocol, such as UDP, each data packet is addressed individually. From the protocol's perspective, each data packet is completely independent and unrelated to any packets coming before or after it.

A good analogy for UDP is postcards. When you send a postcard, there is no guarantee that it will arrive. There is also no way to know if it did arrive. If you send many postcards at once, there is no way to predict what order they will arrive in. It is entirely possible that the first postcard you send gets delayed and arrives weeks after the last postcard was sent.

With UDP, these same caveats apply. UDP makes no guarantee that a packet will arrive. UDP doesn't generally provide a method to know if a packet did not arrive, and UDP does not guarantee that the packets will arrive in the same order they were sent. As you can see, UDP is no more reliable than postcards. In fact, you may consider it less reliable, because with UDP, it is possible that a single packet may arrive twice!

If you need reliable communication, you may be tempted to develop a scheme where you number each packet that's sent. For the first packet sent, you number it one, the second packet sent is numbered two, and so on. You could also request that the receiver send an acknowledgment for each packet. When the receiver gets packet one, it sends a return message, packet one received. In this way, the receiver can be sure that received packets are in the proper order. If the same packet arrives twice, the receiver can just ignore the redundant copy. If a packet isn't received at all, the sender knows from the missing acknowledgment and can resend it.

This scheme is essentially what connection-oriented protocols, such as TCP, do. TCP guarantees that data arrives in the same order it is sent. It prevents duplicate data from arriving twice, and it retries sending missing data. It also provides additional features such as notifications when a connection is terminated and algorithms to mitigate network congestion. Furthermore, TCP implements these features with an efficiency that is not achievable by piggybacking a custom reliability scheme on top of UDP.

For these reasons, TCP is used by many protocols. HTTP (for serving web pages), FTP (for transferring files), SSH (for remote administration), and SMTP (for delivering email) all use TCP. We will cover HTTP, SSH, and SMTP in the coming chapters.

UDP is used by DNS (for resolving domain names). It is suitable for this purpose because an entire request and response can fit in a single packet.

UDP is also commonly used in real-time applications, such as audio streaming, video streaming, and multiplayer video games. In real-time applications, there is often no reason to retry sending dropped packets, so TCP's guarantees are unnecessary. For example, if you are streaming live video and a few packets get dropped, the video simply resumes when the next packet arrives. There is no reason to resend (or even detect) the dropped packet, as the video has already progressed past that point.

UDP also has the advantage in cases where you want to send a message without expecting a response from the other end. This makes it useful when using IP broadcast or multicast. TCP, on the other hand, requires bidirectional communication to provide its guarantees, and TCP does not work with IP multicast or broadcast.

If the guarantees that TCP provides are not needed, then UDP can achieve greater efficiency. This is because TCP adds some additional overhead by numbering packets. TCP must also delay packets that arrive out of order, which can cause unnecessary delays in real-time applications. If you do need the guarantees provided by TCP, however, it is almost always preferable to use TCP instead of trying to add those mechanisms to UDP.

Now that we have an idea of the communication models we use sockets for, let's look at the actual functions that are used in socket programming.

Socket functions

The socket APIs provide many functions for use in network programming. Here are the common socket functions that we use in this book:

1. socket() creates and initializes a new socket.
2. bind() associates a socket with a particular local IP address and port number.
3. listen() is used on the server to cause a TCP socket to listen for new connections.
4. connect() is used on the client to set the remote address and port. In the case of TCP, it also establishes a connection.
5. accept() is used on the server to create a new socket for an incoming TCP connection.
6. send() and recv() are used to send and receive data with a socket.
7. sendto() and recvfrom() are used to send and receive data from sockets without a bound remote address.
8. close() (Berkeley sockets) and closesocket() (Winsock sockets) are used to close a socket. In the case of TCP, this also terminates the connection.
9. shutdown() is used to close one side of a TCP connection. It is useful to ensure an orderly connection teardown.
10. select() is used to wait for an event on one or more sockets.
11. getnameinfo() and getaddrinfo() provide a protocol-independent manner of working with hostnames and addresses.
12. setsockopt() is used to change some socket options.
13. fcntl() (Berkeley sockets) and ioctlsocket() (Winsock sockets) are also used to get and set some socket options.

You may see some Berkeley socket networking programs using read() and write(). These functions don't port to Winsock, so we prefer send() and recv() here. Some other common functions that are used with Berkeley sockets are poll() and dup(). We will avoid these in order to keep our programs portable.

Now that we have an idea of the functions involved, let's consider program design and flow next.

Anatomy of a socket program

Network programming is usually done using a client-server paradigm. In this paradigm, a server listens for new connections at a published address. The client, knowing the server's address, is the one to establish the connection initially. Once the connection is established, the client and the server can both send and receive data. This can continue until either the client or the server terminates the connection.

A traditional client-server model usually implies different behaviors for the client and server. The way web browsing works, for example, is that the server resides at a known address, waiting for connections. A client (web browser) establishes a connection and sends a request that includes which web page or resource it wants to download. The server then checks that it knows what to do with this request and responds appropriately (by sending the web page).

An alternative paradigm is the peer-to-peer model. For example, this model is used by the BitTorrent protocol. In the peer-to-peer model, each peer has essentially the same responsibilities. While a web server is optimized to send requested data from the server to the client, a peer-to-peer protocol is balanced in that data is exchanged somewhat evenly between peers. However, even in the peer-to-peer model, the underlying sockets that are using TCP or UDP aren't created equal. That is, for each peer-to-peer connection, one peer was listening and the other connecting. BitTorrent works by having a central server (called a tracker) that stores a list of peer IP addresses. Each of the peers on that list has agreed to behave like a server and listen for new connections. When a new peer wants to join the swarm, it requests a list of peers from the central server, and then tries to establish a connection to peers on that list while simultaneously listening for new connections from other peers. In summary, a peer-to-peer protocol doesn't so much replace the client-server model; it is just expected that each peer be a client and a server.

Another common protocol that pushes the boundary of the client-server paradigm is FTP. The FTP server listens for connections until the FTP client connects. After the initial connection, the FTP client issues commands to the server. If the FTP client requests a file from the server, the server will attempt to establish a new connection to the FTP client to transfer the file over. So, for this reason, the FTP client first establishes a connection as a TCP client, but later accepts connections like a TCP server.

Network programs can usually be described as one of four types—a TCP server, a TCP client, a UDP server, or a UDP client. Some protocols call for a program to implement two, or even all four types, but it is useful for us to consider each of the four types separately.

TCP program flow

A TCP client program must first know the TCP server's address. This is often input by a user. In the case of a web browser, the server address is either input directly by the user into the address bar, or is known from the user clicking on a link. The TCP client takes this address (for example, http://example.com) and uses the getaddrinfo() function to resolve it into a struct addrinfo structure. The client then creates a socket using a call to socket(). The client then establishes the new TCP connection by calling connect(). At this point, the client can freely exchange data using send() and recv().

A TCP server listens for connections at a particular port number on a particular interface. The program must first initialize a struct addrinfo structure with the proper listening IP address and port number. The getaddrinfo() function is helpful so that you can do this in an IPv4/IPv6 independent way. The server then creates the socket with a call to socket(). The socket must be bound to the listening IP address and port. This is accomplished with a call to bind().

The server program then calls listen(), which puts the socket in a state where it listens for new connections. The server can then call accept(), which will wait until a client establishes a connection to the server. When the new connection has been established, accept() returns a new socket. This new socket can be used to exchange data with the client using send() and recv(). Meanwhile, the first socket remains listening for new connections, and repeated calls to accept() allow the server to handle multiple clients.

Graphically, the program flow of a TCP client and server looks like this: see diagram

The program flow given here should serve as a good example of how basic client-server TCP programs interact. That said, considerable variation on this basic program flow is possible. There is also no rule about which side calls send() or recv() first, or how many times. Both sides could call send() as soon as the connection is established.

Also, note that the TCP client could call bind() before connect() if it is particular about which network interface is being used to connect with. This is sometimes important on servers that have multiple network interfaces. It's often not important for general purpose software.

UDP program flow

A UDP client must know the address of the remote UDP peer in order to send the first packet. The UDP client uses the getaddrinfo() function to resolve the address into a struct addrinfo structure. Once this is done, the client creates a socket of the proper type. The client can then call sendto() on the socket to send the first packet. The client can continue to call sendto() and recvfrom() on the socket to send and receive additional packets. Note that the client must send the first packet with sendto(). The UDP client cannot receive data first, as the remote peer would have no way of knowing where to send data without it first receiving data from the client. This is different from TCP, where a connection is first established with a handshake. In TCP, either the client or server can send the first application data.

A UDP server listens for connections from a UDP client. This server should initialize struct addrinfo structure with the proper listening IP address and port number. The getaddrinfo() function can be used to do this in a protocol-independent way. The server then creates a new socket with socket() and binds it to the listening IP address and port number using bind(). At this point, the server can call recvfrom(), which causes it to block until it receives data from a UDP client. After the first data is received, the server can reply with sendto() or listen for more data (from the first client or any new client) with recvfrom().

Graphically, the program flow of a UDP client and server looks like this: see diagram

We're almost ready to begin implementing our first networked program, but before we begin, we should take care of some cross-platform concerns. Let's work on this now.

Berkeley sockets versus Winsock sockets

As we stated earlier, Winsock sockets were modeled on Berkeley sockets. Therefore, there are many similarities between them. However, there are also many differences we need to be aware of.

In this book, we will try to create each program so that it can run on both Windows and Unix-based operating systems. This is made much easier by defining a few C macros to help us with this.

Header files

As we mentioned earlier, the needed header files differ between implementations. We've already seen how these header file discrepancies can be easily overcome with a preprocessor statement.

Socket data type

In UNIX, a socket descriptor is represented by a standard file descriptor. This means you can use any of the standard UNIX file I/O functions on sockets. This isn't true on Windows, so we simply avoid these functions to maintain portability.

Additionally, in UNIX, all file descriptors (and therefore socket descriptors) are small, non-negative integers. In Windows, a socket handle can be anything. Furthermore, in UNIX, the socket() function returns an int, whereas in Windows it returns a SOCKET. SOCKET is a typedef for an unsigned int in the Winsock headers. As a workaround, I find it useful to either typedef int SOCKET or #define SOCKET int on non-Windows platforms. That way, you can store a socket descriptor as a SOCKET type on all platforms:

#if !defined(_WIN32) 
#define SOCKET int 
#endif

Invalid sockets

On Windows, socket() returns INVALID_SOCKET if it fails. On Unix, socket() returns a negative number on failure. This is particularly problematic as the Windows SOCKET type is unsigned. I find it useful to define a macro to indicate if a socket descriptor is valid or not:

#if defined(_WIN32)
#define ISVALIDSOCKET(s) ((s) != INVALID_SOCKET) 
#else
#define ISVALIDSOCKET(s) ((s) >= 0) 
#endif

Closing sockets

All sockets on Unix systems are also standard file descriptors. For this reason, sockets on Unix systems can be closed using the standard close() function. On Windows, a special close function is used instead—closesocket(). It's useful to abstract out this difference with a macro:

#if defined(_WIN32)
#define CLOSESOCKET(s) closesocket(s) 
#else
#define CLOSESOCKET(s) close(s) 
#endif

Error handling

When a socket function, such as socket(), bind(), accept(), and so on, has an error on a Unix platform, the error number gets stored in the thread-global errno variable. On Windows, the error number can be retrieved by calling WSAGetLastError() instead. Again, we can abstract out this difference using a macro:

#if defined(_WIN32)
#define GETSOCKETERRNO() (WSAGetLastError())
#else
#define GETSOCKETERRNO() (errno)
#endif

With these helper macros out of the way, let's dive into our first real socket program.

Our first program

Now that we have a basic idea of socket APIs and the structure of networked programs, we are ready to begin our first program. By building an actual real-world program, we will learn the useful details of how socket programming actually works.

As an example task, we are going to build a web server that tells you what time it is right now. This could be a useful resource for anybody with a smartphone or web browser that needs to know what time it is right now. They can simply navigate to our web page and find out. This is a good first example because it does something useful but still trivial enough that it won't distract from what we are trying to learn—network programming.

A motivating example

Before we begin the networked program, it is useful to solve our problem with a simple console program first. In general, it is a good idea to work out your program's functionality locally before adding in networked features.
The local, console version of our time-telling program is as follows: see /Users/robertndungu/Documents/Computing/Code-and-IAC/C/local time

Making it networked

To see the functionality of the time program above networked see /Users/robertndungu/Documents/Computing/Code-and-IAC/C/time server

working with ipv6

Please recall the hints.ai_family = AF_INET part of time_server.c near the beginning of the main() function. If this line is changed to hints.ai_family = AF_INET6, then your web server listens for IPv6 connections instead of IPv4 connections. This modified file is included in the GitHub repository as time_server_ipv6.c.

In this case, you should navigate your web browser to http://[::1]:8080 to see the web page. ::1 is the IPv6 loopback address, which tells the web browser to connect to the same machine it's running on. In order to use IPv6 addresses in URLs, you need to put them in square brackets, []. :8080 specifies the port number in the same way that we did for the IPv4 example.

Supporting both IPv4 and IPv6

It is also possible for the listening IPv6 socket to accept IPv4 connections with a dual-stack socket. Not all operating systems support dual-stack sockets. With Linux in particular, support varies between distros. If your operating system does support dual-stack sockets, then I highly recommend implementing your server programs using this feature. It allows your programs to communicate with both IPv4 and IPv6 peers while requiring no extra work on your part.

We can modify time_server_ipv6.c to use dual-stack sockets with only a minor addition. After the call to socket() and before the call to bind(), we must clear the IPV6_V6ONLY flag on the socket. This is done with the setsockopt() function:

/*time_server_dual.c excerpt*/

int option = 0;

if (setsockopt(socket_listen, IPPROTO_IPV6, IPV6_V6ONLY, (void*)&option, sizeof(option)))
{
    fprintf(stderr, "setsockopt() failed. (%d)\n", GETSOCKETERRNO());
    return 1;
}

We first declare option as an integer and set it to 0. IPV6_V6ONLY is enabled by default, so we clear it by setting it to 0. setsockopt() is called on the listening socket. We pass in IPPROTO_IPV6 to tell it what part of the socket we're operating on, and we pass in IPV6_V6ONLY to tell it which flag we are setting. We then pass in a pointer to our option and its length. setsockopt() returns 0 on success.

Windows Vista and later supports dual-stack sockets. However, many Windows headers are missing the definitions for IPV6_V6ONLY. For this reason, it might make sense to include the following code snippet at the top of the file:

/*time_server_dual.c excerpt*/

#if !defined(IPV6_V6ONLY)
#define IPV6_V6ONLY 27
#endif

Keep in mind that the socket needs to be initially created as an IPv6 socket. This is accomplished with the hints.ai_family = AF_INET6 line in our code. When an IPv4 peer connects to our dual-stack server, the connection is remapped to an IPv6 connection. This happens automatically and is taken care of by the operating system. When your program sees the client IP address, it will still be presented as a special IPv6 address. These are represented by IPv6 addresses where the first 96 bits consist of the prefix—0:0:0:0:0:ffff. The last 32 bits of the address are used to store the IPv4 address. For example, if a client connects with the IPv4 address 192.168.2.107, then your dual-stack server sees it as the IPv6 address ::ffff:192.168.2.107.

Networking with inetd

On Unix-like systems, such as Linux or macOS, a service called inetd can be used to turn console-only applications into networked ones. You can configure inetd (with /etc/inetd.conf) with your program's location, port number, protocol (TCP or UDP), and the user you want it to run as. inetd will then listen for connections on your desired port. After an incoming connection is accepted by inetd, it will start your program and redirect all socket input/output through stdin and stdout.
what is a console only application? is a computer program designed to be used via a text only computer interface. These applications typically run in a command line interface or terminal and do not have a GUI option.

Using inetd, we could have time_console.c behave like time_server.c with very minimal changes. We would only need to add in an extra printf() function with the HTTP response header, read from stdin, and configure inetd.

You may be able to use inetd on Windows through Cygwin or the Windows Subsystem for Linux.

questions:

1. What is a socket? is one endpoint of a communication link between systems; it is an abstraction in which your application can send and receive data over the network

2. what is a connectionless protocol? used by the UDP protocol where each data packet is addressed individually. Each data packet is completely independent and unrelated to any packets coming before or after it

what is a connection oriented protocol? Used by the Tcp protocol; guarantees that data arrives in the same order that it was sent whilst preventing duplicate data from arriving twice and resending missing data. It also provides notifications when a connection is terminated and algorithms to mitigate network congestion

3. Is UDP a connectionless or connection-oriented protocol? connectionless protocol

4. Is TCP a connectionless or connection-oriented protocol? connection-oriented protocol

5. What types of applications generally benefit from using the UDP protocol? real time applications and simple protocols like DNS

6. What types of applications generally benefit from using the TCP protocol? those that guaranteed data delivery, error checking, and flow control

7. Does TCP guarantee that data will be transmitted successfully? yes

8. What are some of the main differences between Berkeley sockets and Winsock sockets? initialisation and cleanup process required when using the Winsock windows API. This is not required when using berkley sockets. The header files used also differ between the two APIs; although they do have common ones between them. there exist some function name differences eg close() function in berkley sockets is replaced by closesocket() in winsock.

9. What does the bind() function do? after a socket has been created, a call to bind() is made to associate the socket with the local address obtained from calling getaddrinfo()

10. What does the accept() function do? is used to accept any incoming connections, it creates a new socket for the accepted connection. It also fills in the address info of the client that connected

11. In a TCP connection, does the client or the server send application data first? could be either


C. An indepth overview of TCP connections

Multiplexing TCP connections

The socket APIs are blocking by default. When you use accept() to wait for an incoming connection, your program's execution is blocked until a new incoming connection is actually available. When you use recv() to read incoming data, your program's execution blocks until new data is actually available.

In the last chapter, we built a simple TCP server. This server only accepted one connection, and it only read data from that connection once. Blocking wasn't a problem then, because our server had no other purpose than to serve its one and only client.

In the general case, though, blocking I/O can be a significant problem. Imagine that our server from Chapter 2, Getting to Grips with Socket APIs, needed to serve multiple clients. Then, imagine that one slow client connected to it. Maybe this slow client takes a minute before sending its first data. During this minute, our server would simply be waiting on the recv() call to return. If other clients were trying to connect, they would have to wait it out.

Blocking on recv() like this isn't really acceptable. A real application usually needs to be able to manage several connections simultaneously. This is obviously true on the server side, as most servers are built to manage many connected clients. Imagine running a website where hundreds of clients are connected at once. Serving these clients one at a time would be a non-starter.

Blocking also isn't usually acceptable on the client side either. If you imagine building a fast web browser, it needs to be able to download many images, scripts, and other resources in parallel. Modern web browsers also have a tab feature where many whole web pages can be loaded in parallel.

What we need is a technique for handling many separate connections simultaneously.

Polling non-blocking sockets

It is possible to configure sockets to use a non-blocking operation. One way to do this is by calling fcntl() with the O_NONBLOCK flag (ioctlsocket() with the FIONBIO flag on Windows), although other ways also exist. Once in non-blocking mode, a call to recv() with no data will return immediately. See Chapter 13, Socket Programming Tips and Pitfalls, for more information.

A program structured with this in mind could simply check each of its active sockets in turn, continuously. It would handle any socket that returned data and ignore any socket that didn't. This is called polling. Polling can be a waste of computer resources since most of the time, there will be no data to read. It also complicates the program somewhat, as the programmer is required to manually track which sockets are active and which state, they are in. Return values from recv() must also be handled differently than with blocking sockets. For these reasons, we won't use polling in this book.

Forking and multithreading

Another possible solution to multiplexing socket connections is to start a new thread or process for each connection. In this case, blocking sockets are fine, as they block only their servicing thread/process, and they do not block other threads/processes. This can be a useful technique, but it also has some downsides. First of all, threading is tricky to get right. This is especially true if the connections must share any state between them. It is also less portable as each operating system provides a different API for these features.

On Unix-based systems, such as Linux and macOS, starting a new process is very easy. We simply use the fork() function. The fork() function splits the executing program into two separate processes. A multi-process TCP server may accept connections like this:

while(1) {
    socket_client = accept(socket_listen, &new_client, &new_client_length);     
    int pid = fork();
    if (pid == 0) { //child process
        close(socket_listen);
        recv(socket_client, ...);
        send(socket_client, ...);
        close(socket_client);
        exit(0);
    }
    //parent process
    close(socket_client);
}

In this example, the program blocks on accept(). When a new connection is established, the program calls fork() to split into two processes. The child process, where pid == 0, only services this one connection. Therefore, the child process can use recv() freely without worrying about blocking. The parent process simply calls close() on the new connection and returns to listening for more connections with accept().

Using multiple processes/threads is much more complicated on Windows. Windows provides CreateProcess(), CreateThread(), and many other functions for these features. However—and I can say this objectively—they are all much harder to use than Unix's fork().

Debugging these multi-process/thread programs can be much more difficult compared to the single process case. Communicating between sockets and managing shared state is also much more burdensome. For these reasons, we will avoid fork() and other multiprocess/thread techniques for the rest of this book.

That being said, an example TCP server using fork is included in this chapter's code. It's named tcp_serve_toupper_fork.c. It does not run on Windows, but it should compile and run cleanly on Linux and macOS. I would suggest finishing the rest of this chapter before looking at it.

The select() function

Our preferred technique for multiplexing is to use the select() function. We can give select() a set of sockets, and it tells us which ones are ready to be read. It can also tell us which sockets are ready to write to and which sockets have exceptions. Furthermore, it is supported by both Berkeley sockets and Winsock. Using select() keeps our programs portable.

Synchronous multiplexing with select()

The select() function has several useful features. Given a set of sockets, it can be used to block until any of the sockets in that set is ready to be read from. It can also be configured to return if a socket is ready to be written to or if a socket has an error. Additionally, we can configure select() to return after a specified time if none of these events take place.

The C function prototype for select() is as follows:

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

Before calling select(), we must first add our sockets into an fd_set. If we have three sockets, socket_listen, socket_a, and socket_b, we add them to an fd_set, like this:

fd_set our_sockets;
FD_ZERO(&our_sockets);
FD_SET(socket_listen, &our_sockets);
FD_SET(socket_a, &our_sockets);
FD_SET(socket_b, &our_sockets);

It is important to zero-out the fd_set using FD_ZERO() before use.

Socket descriptors are then added to the fd_set one at a time using FD_SET(). A socket can be removed from an fd_set using FD_CLR(), and we can check for the presence of a socket in the set using FD_ISSET().

You may see some programs manipulating an fd_set directly. I recommend that you use only FD_ZERO(), FD_SET(), FD_CLR(), and FD_ISSET() to maintain portability between Berkeley sockets and Winsock.

select() also requires that we pass a number that's larger than the largest socket descriptor we are going to monitor. (This parameter is ignored on Windows, but we will always do it anyway for portability.) We store the largest socket descriptor in a variable, like this:

SOCKET max_socket;
max_socket = socket_listen;
if (socket_a > max_socket) max_socket = socket_a;
if (socket_b > max_socket) max_socket = socket_b;

When we call select(), it modifies our fd_set of sockets to indicate which sockets are ready. For that reason, we want to copy our socket set before calling it. We can copy an fd_set with a simple assignment like this, and then call select() like this:

fd_set copy;
copy = our_sockets;
select(max_socket+1, &copy, 0, 0, 0);

This call blocks until at least one of the sockets is ready to be read from. When select() returns, copy is modified so that it only contains the sockets that are ready to be read from. We can check which sockets are still in copy using FD_ISSET(), like this:

if (FD_ISSET(socket_listen, &copy)) {
    //socket_listen has a new connection
    accept(socket_listen...
}
if (FD_ISSET(socket_a, &copy)) {
    //socket_a is ready to be read from
    recv(socket_a...
}
if (FD_ISSET(socket_b, &copy)) {
    //socket_b is ready to be read from
    recv(socket_b...
}

In the previous example, we passed our fd_set as the second argument to select(). If we wanted to monitor an fd_set for writability instead of readability, we would pass our fd_set as the third argument to select(). Likewise, we can monitor a set of sockets for exceptions by passing it as the fourth argument to select().

select() timeout

The last argument taken by select() allows us to specify a timeout. It expects a pointer to struct timeval. The timeval structure is declared as follows:

struct timeval {     
    long tv_sec;     
    long tv_usec; 
}

tv_sec holds the number of seconds, and tv_usec holds the number of microseconds (1,000,000th second). If we want select() to wait a maximum of 1.5 seconds, we can call it like this:

struct timeval timeout;
timeout.tv_sec = 1;
timeout.tv_usec = 500000;
select(max_socket+1, &copy, 0, 0, &timeout);

In this case, select() returns after a socket in fd_set copy is ready to read or after 1.5 seconds has elapsed, whichever is sooner.

If timeout.tv_sec = 0 and timeout.tv_usec = 0, then select() returns immediately (after changing the fd_set as appropriate). As we saw previously, if we pass in a null pointer for the timeout parameter, then select() does not return until at least one socket is ready to be read.

select() can also be used to monitor for writeable sockets (sockets where we could call send() without blocking), and sockets with exceptions. We can check for all three conditions with one call:

select(max_sockets+1, &ready_to_read, &ready_to_write, &excepted, &timeout);

On success, select() itself returns the number of socket descriptors contained in the (up to) three descriptor sets it monitored. The return value is zero if it timed out before any sockets were readable/writeable/excepted. select() returns -1 to indicate an error.

Iterating through an fd_set

We can iterate through an fd_set using a simple for loop. Essentially, we start at 1, since all socket descriptors are positive numbers, and we continue through to the largest known socket descriptor in the set. For each possible socket descriptor, we simply use FD_ISSET() to check if it is in the set. If we wanted to call CLOSESOCKET() for every socket in the fd_set master, we could do it like this:

SOCKET i;
for (i = 1; i <= max_socket; ++i) {
    if (FD_ISSSET(i, &master)) {
        CLOSESOCKET(i);
    }
}

This may seem like a brute-force approach, and it actually kind of is. However, these are the tools that we have to work with. FD_ISSET() runs very fast, and it's likely that processor time spent on other socket operations will dwarf what time was spent iterating through them in this manner. Nevertheless, you may be able to optimize this operation by additionally storing your sockets in an array or linked list. I don't recommend that you make this optimization unless you profile your code and find the simple for loop iteration to be a significant bottleneck.

select() on non-sockets

On Unix-based systems, select() can also be used on file and terminal I/O, which can be extremely useful. This doesn't work on Windows, though. Windows only supports select() for sockets.

A TCP client

It will be useful for us to have a TCP client that can connect to any TCP server. This TCP client will take in a hostname (or IP address) and port number from the command line. It will attempt a connection to the TCP server at that address. If successful, it will relay data that's received from that server to the terminal and data inputted into the terminal to the server. It will continue until either it is terminated (with Ctrl + C) or the server closes the connection.

This is useful as a learning opportunity to see how to program a TCP client, but it is also useful for testing the TCP server programs we develop throughout this book.

Our basic program flow looks like this: tcp_client_flow.png

Our program first uses getaddrinfo() to resolve the server address from the command-line arguments. Then, the socket is created with a call to socket(). The fresh socket has connect() called on it to connect to the server. We use select() to monitor for socket input. select() also monitors for terminal/keyboard input on non-Windows systems. On Windows, we use the _kbhit() function to detect terminal input. If terminal input is available, we send it over the socket using send(). If select() indicated that socket data is available, we read it with recv() and display it to the terminal. This select() loop is repeated until the socket is closed.

TCP client code

We begin our TCP client by including the header file, chap03.h, which was printed at the beginning of this chapter. This header file includes the various other headers and macros we need for cross-platform networking:

/*tcp_client.c*/
#include "chap03.h"

On Windows, we also need the conio.h header. This is required for the _kbhit() function, which helps us by indicating whether terminal input is waiting. We conditionally include this header, like so:

#if defined(_WIN32)
#include <conio.h>
#endif

We can then begin the main() function and initialize Winsock: please see TCP client folder in Code-and-IAC/C

int main(int argc, char *argv[]) {
#if defined(_WIN32)
    WSADATA d;
    if (WSAStartup(MAKEWORD(2, 2), &d)) {         
        fprintf(stderr, "Failed to initialize.\n");         
        return 1;
    } 
#endif

We would like our program to take the hostname and port number of the server it should connect to as command-line arguments. This makes our program flexible. We have our program check that these command-line arguments are given. If they aren't, it displays usage information:

if (argc < 3) {
    fprintf(stderr, "usage: tcp_client hostname port\n");
    return 1;
}

argc contains the number of argument values available to us. Because the first argument is always our program's name, we check that there is a total of at least three arguments. The actual values themselves are stored in argv[].

We then use these values to configure a remote address for connection:

printf("Configuring remote address...\n");
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_socktype = SOCK_STREAM;
struct addrinfo *peer_address;
if (getaddrinfo(argv[1], argv[2], &hints, &peer_address)) {         
    fprintf(stderr, "getaddrinfo() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}

This is similar to how we called getaddrinfo() in Chapter 2, Getting to Grips with Socket APIs. However, in Chapter 2, Getting to Grips with Socket APIs, we wanted it to configure a local address, whereas this time, we want it to configure a remote address.

We set hints.ai_socktype = SOCK_STREAM to tell getaddrinfo() that we want a TCP connection. Remember that we could set SOCK_DGRAM to indicate a UDP connection.

In Chapter 2, Getting to Grips with Socket APIs, we also set the family. We don't need to set the family here, as we can let getaddrinfo() decide if IPv4 or IPv6 is the proper protocol to use.

For the call to getaddrinfo() itself, we pass in the hostname and port as the first two arguments. These are passed directly in from the command line. If they aren't suitable, then getaddrinfo() returns non-zero and we print an error message. If everything goes well, then our remote address is in the peer_address variable.

getaddrinfo() is very flexible about how it takes inputs. The hostname could be a domain name like example.com or an IP address such as 192.168.17.23 or ::1. The port can be a number, such as 80, or a protocol, such as http.

After getaddrinfo() configures the remote address, we print it out. This isn't really necessary, but it is a good debugging measure. We use getnameinfo() to convert the address back into a string, like this:

printf("Remote address is: ");
char address_buffer[100];
char service_buffer[100];
getnameinfo(peer_address->ai_addr, peer_address->ai_addrlen, address_buffer, sizeof(address_buffer), service_buffer, 
            sizeof(service_buffer), NI_NUMERICHOST);
printf("%s %s\n", address_buffer, service_buffer);

We can then create our socket:

printf("Creating socket...\n");
SOCKET socket_peer;
socket_peer = socket(peer_address->ai_family, peer_address->ai_socktype, peer_address->ai_protocol);
if (!ISVALIDSOCKET(socket_peer)) {
    fprintf(stderr, "socket() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}

This call to socket() is done in exactly the same way as it was in Chapter 2, Getting to Grips with Socket APIs. We use peer_address to set the proper socket family and protocols. This keeps our program very flexible, as the socket() call creates an IPv4 or IPv6 socket as needed.

After the socket has been created, we call connect() to establish a connection to the remote server:

printf("Connecting...\n");
if (connect(socket_peer, peer_address->ai_addr, peer_address->ai_addrlen)) {         
    fprintf(stderr, "connect() failed. (%d)\n", GETSOCKETERRNO());
    return 1;
}
freeaddrinfo(peer_address);

connect() takes three arguments—the socket, the remote address, and the remote address length. It returns 0 on success, so we print an error message if it returns non-zero. This call to connect() is extremely similar to how we called bind() in Chapter 2, Getting to Grips with Socket APIs. Where bind() associates a socket with a local address, connect() associates a socket with a remote address and initiates the TCP connection.

After we've called connect() with peer_address, we use the freeaddrinfo() function to free the memory for peer_address.

If we've made it this far, then a TCP connection has been established to the remote server. We let the user know by printing a message and instructions on how to send data:

printf("Connected.\n");
printf("To send data, enter text followed by enter.\n");

Our program should now loop while checking both the terminal and socket for new data. If new data comes from the terminal, we send it over the socket. If new data is read from the socket, we print it out to the terminal.

It is clear we cannot call recv() directly here. If we did, it would block until data comes from the socket. In the meantime, if our user enters data on the terminal, that input is ignored. Instead, we use select(). We begin our loop and set up the call to select(), like this:

while(1) {
    fd_set reads;
    FD_ZERO(&reads);
    FD_SET(socket_peer, &reads);
#if !defined(_WIN32)
    FD_SET(0, &reads);
#endif
    struct timeval timeout;
    timeout.tv_sec = 0;
    timeout.tv_usec = 100000;

    if (select(socket_peer+1, &reads, 0, 0, &timeout) < 0) {
        fprintf(stderr, "select() failed. (%d)\n", GETSOCKETERRNO());           
        return 1;
    }

First, we declare a variable, fd_set reads, to store our socket set. We then zero it with FD_ZERO() and add our only socket, socket_peer.

On non-Windows systems, we also use select() to monitor for terminal input. We add stdin to the reads set with FD_SET(0, &reads). This works because 0 is the file descriptor for stdin. Alternatively, we could have used FD_SET(fileno(stdin),
&reads) to the same effect.

The Windows select() function only works on sockets. Therefore, we cannot use select() to monitor for console input. For this reason, we set up a timeout to the select() call for 100 milliseconds (100,000 microseconds). If there is no socket activity after 100 milliseconds, select() returns, and we can check for terminal input manually.

After select() returns, we check to see whether our socket is set in reads. If it is, then we know to call recv() to read the new data. The new data is printed to the console with printf(): 

if (FD_ISSET(socket_peer, &reads)) {
    char read[4096];
    int bytes_received = recv(socket_peer, read, 4096, 0);             
    if (bytes_received < 1) {
        printf("Connection closed by peer.\n");                 
        break;
    }
    printf("Received (%d bytes): %.*s", bytes_received, bytes_received, read);
}

Remember, the data from recv() is not null terminated. For this reason, we use the %.*s printf() format specifier, which prints a string of a specified length.

recv() normally returns the number of bytes read. If it returns less than 1, then the connection has ended, and we break out of the loop to shut it down.

After checking for new TCP data, we also need to check for terminal input:

#if defined(_WIN32)         
    if(_kbhit()) {
#else
    if(FD_ISSET(0, &reads)) {
#endif
        char read[4096];
        if (!fgets(read, 4096, stdin)) break;
        printf("Sending: %s", read);
        int bytes_sent = send(socket_peer, read, strlen(read), 0);             
        printf("Sent %d bytes.\n", bytes_sent);
    }

On Windows, we use the _kbhit() function to indicate whether any console input is waiting. _kbhit() returns non-zero if an unhandled key press event is queued up. For Unix-based systems, we simply check if select() sets the stdin file descriptor, 0. If input is ready, we call fgets() to read the next line of input. This input is then sent over our connected socket with send().

Note that fgets() includes the newline character from the input. Therefore, our sent input always ends with a newline.

If the socket has closed, send() returns -1. We ignore this case here. This is because a closed socket causes select() to return immediately, and we notice the closed socket on the next call to recv(). This is a common paradigm in TCP socket programming to ignore errors on send() while detecting and handling them on recv(). It allows us to simplify our program by keeping our connection closing logic all in one place. Later in this chapter, we will discuss other concerns regarding send().

This select() based terminal monitoring works very well on Unix-based systems. It also works equally well if input is piped in. For example, you could use our TCP client program to send a text file with a command such as cat my_file.txt | tcp_client 192.168.54.122 8080.

The Windows terminal handling leaves a bit to be desired. Windows does not provide an easy way to tell whether stdin has input available without blocking, so we use _kbhit() as a poor proxy. However, if the user presses a non-printable key, such as an arrow key, it still triggers _kbhit(), even though there is no character to read. Also, after the first key press, our program will block on fgets() until the user presses the Enter key. (This doesn't happen on shells that buffer entire lines, which is common outside of Windows.) This blocking behavior is acceptable, but you should know that any received TCP data will not display until after that point. _kbhit() does not work for piped input. Doing proper piped and console input on Windows is possible, of course, but it's very complicated.

We would need to use separate functions for each (PeekNamedPipe() and PeekConsoleInput()), and the logic for handling it would be as long as this entire program! Since handling terminal input isn't the purpose of this book, we're going to accept _kbhit() function's limitations and move on.

At this point, our program is essentially done. We can end the while loop, close our socket, and clean up Winsock:

    }
    printf("Closing socket...\n");
    CLOSESOCKET(socket_peer);
#if defined(_WIN32)
    WSACleanup();
#endif
    printf("Finished.\n");
    return EXIT_SUCCESS;
}

That's the complete program. You can compile it on Linux and macOS like this:
gcc tcp_client.c -o tcp_client

Compiling on Windows with MinGW is done like this:
gcc tcp_client.c -o tcp_client.exe -lws2_32

To run the program, remember to pass in the remote hostname/address and port number, for example:
tcp_client example.com 80
Alternatively, you can use the following command:
tcp_client 127.0.0.1 8080

A fun way to test out the TCP client would be to connect to a live web server and send an HTTP request. For example, you could connect to example.com on port 80 and send the following HTTP request:
GET / HTTP/1.1
Host: example.com

You must then send a blank line to indicate the end of the request. You'll receive an HTTP response back. It might look something like this: see image on page 87

A TCP server

Microservices have become increasingly popular in recent years. The idea of microservices is that large programming problems can be split up into many small subsystems that communicate over a network. For example, if your program needs to format a string, you could add code to your program to do that, but writing code is hard. Alternatively, you could keep your program simple and instead connect to a service that provides string formatting for you. This has the added advantage that many programs can use this same service without reinventing the wheel.

Unfortunately, the microservice paradigm has largely avoided the C ecosystem; until now!

As a motivating example, we are going to build a TCP server that converts strings into uppercase. If a client connects and sends Hello, then our program will send HELLO back. This will serve as a very basic microservice. Of course, a real-world microservice might do something a bit more advanced (such as left-pad a string), but this to-uppercase service works well for our pedagogical purposes.

For our microservice to be useful, it does need to handle many simultaneous incoming connections. We again use select() to see which connections need to be serviced.

Our basic program flow looks like this: view image on page 89

Like in Chapter 2, Getting to Grips with Socket APIs, our TCP server uses getaddrinfo() to obtain the local address to listen on. It creates a socket with socket(), uses bind() to associate the local address to the socket, and uses listen() to begin listening for new connections. Up until that point, it is essentially identical to our TCP server from Chapter 2, Getting to Grips with Socket APIs.

However, our next step is not to call accept() to wait for new connections. Instead, we call select(), which alerts us if a new connection is available or if any of our established connections have new data ready. Only when we know that a new connection is waiting do we call accept(). All established connections are put into an fd_set, which is passed to every subsequent select() call. In this same way, we know which connections would block on recv(), and we only service those connections that we know will not block.

When data is received by recv(), we run it through toupper() and return it to the client using send().

This is a complicated program with several new concepts. Don't worry about understanding all the details right now. The flow is only intended to give you an overview of what to expect before we dive into the actual code.

TCP server code

Our TCP server code begins by including the needed headers, starting main(), and initializing Winsock. Refer to Chapter 2, Getting to Grips with Socket APIs, if this doesn't seem familiar:

#include "chap03.h"
#include <ctype.h>

int main()
{
#if defined(_WIN32)
    WSADATA d;
    if (WSAStartup(MAKEWORD(2, 2), &d)) {         
        fprintf(stderr, "Failed to initialize.\n");         
        return 1;
    } 
#endif
}

We then get our local address, create our socket, and bind(). This is all done exactly as explained in Chapter 2, Getting to Grips with Socket APIs:

printf("Configuring local address...\n");
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;
struct addrinfo *bind_address;
getaddrinfo(0, "8080", &hints, &bind_address);
printf("Creating socket...\n");
SOCKET socket_listen;
socket_listen = socket(bind_address->ai_family, bind_address->ai_socktype,bind_address->ai_protocol);     if (!ISVALIDSOCKET(socket_listen)) {
    fprintf(stderr, "socket() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}

Note that we are going to listen on port 8080. You can, of course, change that. We're also doing an IPv4 server here. If you want to listen for connections on IPv6, then just change AF_INET to AF_INET6.

We then bind() our socket to the local address and have it enter a listening state. Again, this is done exactly as in Chapter 2, Getting to Grips with Socket APIs: 

printf("Binding socket to local address...\n");
if (bind(socket_listen, bind_address->ai_addr, bind_address->ai_addrlen)) {         
    fprintf(stderr, "bind() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}
freeaddrinfo(bind_address);
printf("Listening...\n");
if (listen(socket_listen, 10) < 0) {
    fprintf(stderr, "listen() failed. (%d)\n", GETSOCKETERRNO());         return 1;
}

This is the point where we diverge from our earlier methods. We now define an fd_set structure that stores all of the active sockets. We also maintain a max_socket variable, which holds the largest socket descriptor. For now, we add only our listening socket to the set. Because it's the only socket, it must also be the largest, so we set
max_socket = socket_listen too:

fd_set master;
FD_ZERO(&master);
FD_SET(socket_listen, &master);
SOCKET max_socket = socket_listen;

Later in the program, we will add new connections to master as they are established. We then print a status message, enter the main loop, and set up our call to select():

printf("Waiting for connections...\n");
while(1) {
    fd_set reads;
    reads = master;
    if (select(max_socket+1, &reads, 0, 0, 0) < 0) {             
        fprintf(stderr, "select() failed. (%d)\n", GETSOCKETERRNO());             
        return 1;
    }

This works by first copying our fd_set master into reads. Recall that select() modifies the set given to it. If we didn't copy master, we would lose its data.

We pass a timeout value of 0 (NULL) to select() so that it doesn't return until a socket in the master set is ready to be read from. At the beginning of our program, master only contains socket_listen, but as our program runs, we add each new connection to master.

We now loop through each possible socket and see whether it was flagged by select() as being ready. If a socket, X, was flagged by select(), then FD_ISSET(X, &reads) is true. Socket descriptors are positive integers, so we can try every possible socket descriptor up to max_socket. The basic structure of our loop is as follows:

SOCKET i;
for(i = 1; i <= max_socket; ++i) {
    if (FD_ISSET(i, &reads)){
        //Handle socket
    } 
}

Remember, FD_ISSET() is only true for sockets that are ready to be read. In the case of socket_listen, this means that a new connection is ready to be established with accept(). For all other sockets, it means that data is ready to be read with recv(). We should first determine whether the current socket is the listening one or not. If it is, we call accept(). This code snippet and the one that follows replace the //Handle socket comment in the preceding code:

if (i == socket_listen) {
    struct sockaddr_storage client_address;                     
    socklen_t client_len = sizeof(client_address);                     
    SOCKET socket_client = accept(socket_listen, (struct sockaddr*) &client_address, &client_len);
    if (!ISVALIDSOCKET(socket_client)) {                         
        fprintf(stderr, "accept() failed. (%d)\n", GETSOCKETERRNO());                         
        return 1;
    }
    FD_SET(socket_client, &master);                     
    if (socket_client > max_socket)                         
        max_socket = socket_client;

    char address_buffer[100];
    getnameinfo((struct sockaddr*)&client_address, client_len, address_buffer, sizeof(address_buffer), 0 ,0,     NI_NUMERICHOST);
    printf("New connection from %s\n", address_buffer);

If the socket is socket_listen, then we accept() the connection much as we did in Chapter 2, Getting to Grips with Socket APIs. We use FD_SET() to add the new connection's socket to the master socket set. This allows us to monitor it with subsequent calls to select(). We also maintain max_socket. As a final step, this code prints out the client's address using getnameinfo().

If the socket i is not socket_listen, then it is instead a request for an established connection. In this case, we need to read it with recv(), convert it into uppercase using the built-in toupper() function, and send the data back:

} 
else 
{
    char read[1024];
    int bytes_received = recv(i, read, 1024, 0);                     
    if (bytes_received < 1) {
        FD_CLR(i, &master);
        CLOSESOCKET(i);
        continue;
    }
    int j;
    for (j = 0; j < bytes_received; ++j)                         
        read[j] = toupper(read[j]);                    
    send(i, read, bytes_received, 0);
}

If the client has disconnected, then recv() returns a non-positive number. In this case, we remove that socket from the master socket set, and we also call CLOSESOCKET() on it to clean up.

Our program is now almost finished. We can end the if FD_ISSET() statement, end the for loop, end the while loop, close the listening socket, and clean up Winsock:

            } //if FD_ISSET
        } //for i to max_socket
    } //while(1)
    printf("Closing listening socket...\n");     
    CLOSESOCKET(socket_listen);
#if defined(_WIN32)
    WSACleanup();
#endif
    printf("Finished.\n");     
    return 0;
}

Our program is set up to continuously listen for connections, so the code after the end of the while loop will never run. Nevertheless, I believe it is still good practice to include it in case we program in functionality later to abort the while loop.

That's the complete to-uppercase microservice TCP server program. You can compile and run it on Linux and macOS like this:

gcc tcp_serve_toupper.c -o tcp_serve_toupper
./tcp_serve_toupper

Compiling and running on Windows with MinGW is done like this:

gcc tcp_serve_toupper.c -o tcp_serve_toupper.exe -lws2_32
tcp_serve_toupper.exe

You can abort the program's execution with Ctrl + C.

Once the program is running, I would suggest opening another terminal and running the tcp_client program from earlier to connect to it:

tcp_client 127.0.0.1 8080

Anything you type in tcp_client should be sent back as uppercase. Here's what this might look like: look at page 95

As a test of the server program's functionality, try opening several additional terminals and connecting with tcp_client. Our server should be able to handle many simultaneous connections.

Also included with this chapter's code is tcp_serve_toupper_fork.c. This program only runs on Unix-based operating systems, but it performs the same functions as tcp_serve_toupper.c by using fork() instead of select(). The fork() function is commonly used by TCP servers, so I think it's helpful to be familiar with it.

Building a chat room

It is also possible, and common, to need to send data between connected clients. We can modify our tcp_serve_toupper.c program and make it a chat room pretty easily.

First, locate the following code in tcp_serve_toupper.c:

/*tcp_serve_toupper.c excerpt*/
                    int j;
                    for (j = 0; j < bytes_received; ++j)                        
                        read[j] = toupper(read[j]);                     
                    send(i, read, bytes_received, 0);

Replace the preceding code with the following:

/*tcp_serve_chat.c excerpt*/
                    SOCKET j;
                    for (j = 1; j <= max_socket; ++j) {                         
                        if (FD_ISSET(j, &master)) {                             
                            if (j == socket_listen || j == i)                                 
                                continue;
                            else
                                send(j, read, bytes_received, 0);
                        }
                    }

This works by looping through all the sockets in the master set. For each socket, j, we check that it's not the listening socket and we check that it's not the same socket that sent the data in the first place. If it's not, we call send() to echo the received data to it.

You can compile and run this program in the same way as the previous one.

On Linux and macOS, this is done as follows:

gcc tcp_serve_chat.c -o tcp_serve_chat
./tcp_serve_chat

On Windows, this is done as follows:

gcc tcp_serve_chat.c -o tcp_serve_chat.exe -lws2_32 tcp_serve_chat.exe

You should open two or more additional windows and connect to it with the following code:

tcp_client 127.0.0.1 8080

Whatever you type in one of the tcp_client terminals get sent to all of the other connected terminals.

Here is an example of what this may look like: look snapshots on page 97

In the preceding screenshot, I am running tcp_serve_chat in the upper-left terminal windows. The other three terminal windows are running tcp_client. As you can see, any text entered in one of the tcp_client windows is sent to the server, which relays it to the other two connected clients.

Blocking on send()

When we call send() with an amount of data, send() first copies this data into an outgoing buffer provided by the operating system. If we call send() when its outgoing buffer is already full, it blocks until its buffer has emptied enough to accept more of our data.

In some cases where send() would block, it instead returns without copying all of the data as requested. In this case, the return value of send() indicates how many bytes were actually copied. One example of this is if your program is blocking on send() and then receives a signal from the operating system. In these cases, it is up to the caller to try again with any remaining data.

In this chapter's TCP server code section, we ignored the possibility that send() could block or be interrupted. In a fully robust application, what we need to do is compare the return value from send() with the number of bytes that we tried to send. If the number of bytes actually sent is less than requested, we should use select() to determine when the socket is ready to accept new data, and then call send() with the remaining data. As you can imagine, this can become a bit complicated when keeping track of multiple sockets.

As the operating system usually provides a large enough outgoing buffer, we were able to avoid this possibility with our earlier server code. If we know that our server may try to send large amounts of data, we should certainly check for the return value from send().

The following code example assumes that buffer contains buffer_len bytes of data to send over a socket called peer_socket. This code blocks until we've sent all of buffer or an error (such as the peer disconnecting) occurs:

int begin = 0;
while (begin < buffer_len) {
    int sent = send(peer_socket, buffer + begin, buffer_len - begin, 0);     
    if (sent == -1) {
        //Handle error     
    }
    begin += sent; 
}

If we are managing multiple sockets and don't want to block, then we should put all sockets with pending send() into an fd_set and pass it as the third parameter to select(). When select() signals on these sockets, then we know that they are ready to send more data.
Chapter 13, Socket Programming Tips and Pitfalls, addresses concerns regarding the send() function's blocking behavior in more detail.

TCP is a stream protocol

A common mistake beginners make is assuming that any data passed into send() can be read by recv() on the other end in the same amount. In reality, sending data is similar to writing and reading from a file. If we write 10 bytes to a file, followed by another 10 bytes, then the file has 20 bytes of data. If the file is to be read later, we could read 5 bytes and 15 bytes, or we could read all 20 bytes at once, and so on. In any case, we have no way of knowing that the file was written in two 10 byte chunks.

Using send() and recv() works the same way. If you send() 20 bytes, it's not possible to tell how many recv() calls these bytes are partitioned into. It is possible that one call to recv() could return all 20 bytes, but it is also possible that a first call to recv() returns 16 bytes and that a second call to recv() is needed to get the last 4 bytes.

This can make communication difficult. In many protocols, as we will see later in this book, it is important that received data be buffered up until enough of it has accumulated to warrant processing. We avoided this issue in this chapter with our to-uppercase sever by defining a protocol that operates just as well on 1 byte as it does on 100. This isn't true for most application protocols.

For a concrete example, imagine we wanted to make our tcp_serve_toupper server terminate if it received the quit command through a TCP socket. You could call send(socket, "quit", 4, 0) on the client and you may think that a call to recv() on the server would return quit. Indeed, in your testing, it is very likely to work that way. However, this behavior is not guaranteed. A call to recv() could just as likely return qui, and a second call to recv() may be required to receive the last t. If that is the case, consider how you would interpret whether a quit command has been received. The straightforward way to do it would be to buffer up data that's received from multiple recv() calls.

We will cover techniques for dealing with recv() buffering in Section 2, An Overview of Application Layer Protocols, of this book.
In contrast to TCP, UDP is not a stream protocol. With UDP, a packet is received with exactly the same contents as it was sent with. This can sometimes make handling UDP somewhat easier, as we will see in Chapter 4, Establishing UDP Connections.

4. Establishing UDP Connections

The socket API for UDP sockets is only very slightly different than what we've already learned for TCP. In fact, they are similar enough that we can take the TCP client from the last chapter and turn it into a fully functional UDP client by changing only one line of code:

1. Take tcp_client.c from Chapter 3, An In-Depth Overview of TCP Connections, and find the following line of code:

hints.ai_socktype = SOCK_STREAM;

2. Change the preceding code to the following:

hints.ai_socktype = SOCK_DGRAM;

You can recompile the program using the same commands as before, and you'll get a fully functional UDP client.
Unfortunately, changing the TCP servers of the previous chapters to UDP won't be as easy. TCP and UDP server code are different enough that a slightly different approach is needed.
Also, don't assume that because we had to change only one line of the code that the client behaves exactly the same way – this won't happen. The two programs are using a different protocol, after all.

Remember from Chapter 2, Getting to Grips with Socket APIs that UDP does not try to be a reliable protocol. Lost packets are not automatically re-transmitted, and packets may be received in a different order than they were sent. It is even possible for one packet to erroneously arrive twice! TCP attempts to solve all these problems, but UDP leaves you to your own devices.

Despite UDP's (lack of) reliability, it is still appropriate for many applications. Let's look at the methods that are used by UDP clients and servers.

UDP client methods

Sending data with TCP requires calling connect() to set the remote address and establish the TCP connection. Thus, we use send() with TCP sockets, as shown in the following code:

connect(tcp_socket, peer_address, peer_address_length);
send(tcp_socket, data, data_length, 0);

UDP is a connectionless protocol. Therefore, no connection is established before sending data. A UDP connection is never established. With UDP, data is simply sent and received. We can call connect() and then send(), as we mentioned previously, but the socket API provides an easier way for UDP sockets in the form of the sendto() function. It works like this:

sendto(udp_socket, data, data_length, 0, peer_address, peer_address_length);

connect() on a UDP socket works a bit differently. All connect() does with a UDP socket is associate a remote address. Thus, while connect() on a TCP socket involves a handshake for sending packets over the network, connect() on a UDP socket only stores an address locally.

So, a UDP client can be structured in two different ways, depending on whether you use connect(), send(), and recv(), or instead use sendto() and recvfrom().

The following diagram compares the program flow of a TCP Client to a UDP Client using either method: see Chapter 4: Establishing UDP Connections

Note that, while using connect(), the UDP Client only receives data from the peer having the IP address and the port that is given to connect(). However, when not using connect(), the recvfrom() function returns data from any peer that addresses us! Of course, that peer would need to know our address and port. Unless we call bind(), our local address and port is assigned automatically by the operating system.

UDP server methods

Programming a UDP server is a bit different than TCP. TCP requires managing a socket for each peer connection. With UDP, our program only needs one socket. That one socket can communicate with any number of peers.

While the TCP program flow required us to use listen() and accept() to wait for and establish new connections, these functions are not used with UDP. Our UDP server simply binds to the local address, and then it can immediately start sending and receiving data.

The program flow of a TCP Server compared to a UDP Server is as follows: see diagram

With either a TCP or UDP server, we use select() when we need to check/wait for incoming data. The difference is that a TCP Server using select() is likely monitoring many separate sockets, while a UDP Server often only needs to monitor one socket. If your program uses both TCP and UDP sockets, you can monitor them all with only one call to select().

A first UDP client/server

To keep things simple, we will create a UDP client program that simply sends the Hello World string to 127.0.0.1 on port 8080. Our UDP server listens on 8080. It prints any data it receives, along with the sender's address and port number.

A simple UDP server

We will start with the server, since we already have a usable UDP client, that
is, udp_client.c.

Like all of our networked programs, we will begin by including the necessary headers, starting with the main() function, and initializing Winsock as follows:

#include "chap04.h"

int main() {
#if defined(_WIN32)

    WSADATA d;
    if (WSAStartup(MAKEWORD(2, 2), &d)) {         
        fprintf(stderr, "Failed to initialize.\n");         
        return 1;
    }
#endif

Then, we must configure the local address that our server listens on. We use getaddrinfo() for this, as follows:

printf("Configuring local address...\n");
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_DGRAM;
hints.ai_flags = AI_PASSIVE;
struct addrinfo *bind_address;
getaddrinfo(0, "8080", &hints, &bind_address);

This differs only slightly from how we've done it before. Notably, we set hints.ai_socktype = SOCK_DGRAM. Recall that SOCK_STREAM was used there for TCP connections. We are still setting hints.ai_family = AF_INET here. This makes our server listen for IPv4 connections. We could change that to AF_INET6 to make our server listen for IPv6 connections instead.

After we have our local address information, we can create the socket, as follows:

printf("Creating socket...\n");
SOCKET socket_listen;
socket_listen = socket(bind_address->ai_family, bind_address->ai_socktype, bind_address->ai_protocol);    
if(!ISVALIDSOCKET(socket_listen)) {
    fprintf(stderr, "socket() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}

This code is exactly the same as in the TCP case. The call to socket() uses our address information from getaddrinfo() to create the proper type of socket.

We must then bind the new socket to the local address that we got from getaddrinfo(). This is as follows:

printf("Binding socket to local address...\n");     
if (bind(socket_listen, bind_address->ai_addr, bind_address->ai_addrlen)) {         
    fprintf(stderr, "bind() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}
freeaddrinfo(bind_address);

Again, that code is exactly the same as in the TCP case.

Here is where the UDP server diverges from the TCP server. Once the local address is bound, we can simply start to receive data. There is no need to call listen() or accept(). We listen for incoming data using recvfrom(), as shown here:

struct sockaddr_storage client_address;
socklen_t client_len = sizeof(client_address);
char read[1024];
int bytes_received = recvfrom(socket_listen, read, 1024, 0, (struct sockaddr*) &client_address, &client_len);

In the previous code, we created a struct sockaddr_storage to store the client's address. We also defined socklen_t client_len to hold the address size. This keeps our code robust in the case that we change it from IPv4 to IPv6. Finally, we created a buffer, char read[1024], to store incoming data.

recvfrom() is used in a similar manner to recv(), except that it returns the sender's address, as well as the received data. You can think of recvfrom() as a combination of the TCP server accept() and recv().

Once we've received data, we can print it out. Keep in mind that the data may not be null terminated. It can be safely printed with the %.*s printf() format specifier, as shown in the following code:

printf("Received (%d bytes): %.*s\n", bytes_received, bytes_received, read);

It may also be useful to print the sender's address and port number. We can use the getnameinfo() function to convert this data into a printable string, as shown in the following code:

printf("Remote address is: ");
char address_buffer[100];
char service_buffer[100];
getnameinfo(((struct sockaddr*)&client_address), client_len, address_buffer, sizeof(address_buffer),
            service_buffer, sizeof(service_buffer), NI_NUMERICHOST | NI_NUMERICSERV);
printf("%s %s\n", address_buffer, service_buffer);

