Network programming is a fun topic, but it's also a very deep one; a lot is going on at many levels. Some programming languages hide these abstractions. In Python for example, you can download an entire web page using only one line of code. This isn't the case in C! In C, if you want to download a web page, you have to know how everything works. You need to know sockets, you need to know Transfer Control Protocol (TCP), and you need to know HTTP. In C network programming, nothing is hidden.

C is a great language to learn network programming in. This is not only because we get to see all the details, but also because the popular operating systems all use kernels written in C. No other language gives you the same first-class access as C does. In C, everything is under your control – you can lay out your data structures exactly how you want, manage memory precisely as you please, and even shoot yourself in the foot just the way you want.

There is a lot of C networking code that is done wrong. Internet tutorials about C sockets often use deprecated functions and ignore memory safety completely. When it comes to network programming, you can't take the it works so it's good enough programming-by-coincidence approach. You have to use reasoning.

source code form the book can be found here https://github.com/codeplea/Hands-On-Network-Programming-with-C

chapter 1

The use of the C programming language is ubiquitous. Almost every network stack is programmed in C. This is true for Windows, Linux, and macOS. If your mobile phone uses Android or iOS, then even though the apps for these were programmed in a different language (Java and Objective C), the kernel and networking code was written in C. It is very likely that the network routers that your internet data goes through are programmed in C. Even if the user interface and higher-level functions of your modem or router are programmed in another language, the networking drivers are still probably implemented in C.

Networking encompasses concerns at many different abstraction levels. The concerns your web browser has with formatting a web page are much different than the concerns your router has with forwarding network packets. For this reason, it is useful to have a theoretical model that helps us to understand communications at these different levels of abstraction. Let's look at these models now.

OSI layer model

It's clear that if all of the disparate devices composing the internet are going to communicate seamlessly, there must be agreed-upon standards that define their communications. These standards are called protocols. Protocols define everything from the voltage levels on an Ethernet cable to how a JPEG image is compressed on a web page. It's clear that, when we talk about the voltage on an Ethernet cable, we are at a much different level of abstraction compared to talking about the JPEG image format. If you're programming a website, you don't want to think about Ethernet cables or Wi-Fi frequencies. Likewise, if you're programming an internet router, you don't want to have to worry about how JPEG images are compressed. For this reason, we break the problem down into many smaller pieces.

One common method of breaking down the problem is to place levels of concern into layers. Each layer then provides services for the layer on top of it, and each upper layer can rely on the layers underneath it without concern for how they work.

The most popular layer system for networking is called the Open Systems Interconnection model (OSI model). It was standardized in 1977 and is published as ISO 7498. It has seven layers:

Let's understand these layers one by one:

Physical (1): This is the level of physical communication in the real world.  At this level, we have specifications for things such as the voltage levels on an Ethernet cable, the radio frequency of Wi-Fi etc
Data Link (2): This level builds on the physical layer. It deals with protocols for directly communicating between two nodes.
Network layer (3): The network layer provides the methods to transmit data sequences (called packets) between nodes in different networks.
Transport layer (4): At this layer, we have methods to reliably deliver variable length data between hosts. These methods deal with splitting up data, recombining it, ensuring data arrives in order, and so on. TCP and UDP protocols are in this layer.
Session layer (5): This layer builds on the transport layer by adding methods to establish, checkpoint, suspend, resume, and terminate dialogs.
Presentation layer (6): This is the lowest layer at which data structure and presentation for an application are defined. Concerns such as data encoding, serialization, and encryption are handled here.
Application layer (7): The applications that the user interfaces with (for example, web browsers and email clients) exist here. These applications make use of the services provided by the six lower layers.

In the OSI model, an application, such as a web browser, exists in the application layer (layer 7). A protocol from this layer, such as HTTP used to transmit web pages, doesn't have to concern itself with how the data is being transmitted. It can rely on services provided by the layer underneath it to effectively transmit data. see diagram

It should be noted that chunks of data are often referred to by different names depending on the OSI layer they're on. A data unit on layer 2 is called a frame, since layer 2 is responsible for framing messages. A data unit on layer 3 is referred to as a packet, while a data unit on layer 4 is a segment if it is part of a TCP connection or a datagram if it is a UDP message.

In this book, we often use the term packet as a generic term to refer to a data unit on any layer. However, segment will only be used in the context of a TCP connection, and datagram will only refer to UDP datagrams.

The OSI model doesn't fit precisely with the common protocols in use today. However, it is still a handy model to explain networking concerns, and it is still in widespread use for that purpose today.

TCP/IP layer model

The TCP/IP protocol suite is the most common network communication model in use today. The TCP/IP reference model differs a bit from the OSI model, as it has only four layers instead of seven.

The following diagram illustrates how the four layers of the TCP/IP model line up to the seven layers of the OSI model: see diagram

Notably, the TCP/IP model doesn't match up exactly with the layers in the OSI model. That's OK. In both models, the same functions are performed; they are just divided differently.

The four layers of the TCP/IP model are as follows:

Network Access layer (1): On this layer, physical connections and data framing happen. Sending an Ethernet or Wi-Fi packet are examples of layer 1 concerns.

Internet layer (2): This layer deals with the concerns of addressing packets and routing them over multiple interconnection networks. It's at this layer that an IP address is defined.

Host-to-Host layer (3): The host-to-host layer provides two protocols, TCP and UDP, which we will discuss in the next few chapters. These protocols address concerns such as data order, data segmentation, network congestion, and error correction.

Process/Application layer (4): The process/application layer is where protocols such as HTTP, SMTP, and FTP are implemented. Most of the programs that feature in this book could be considered to take place on this layer while consuming functionality provided by our operating system's implementation of the lower layers.

Regardless of your chosen abstraction model, real-world protocols do work at many levels. Lower levels are responsible for handling data for the higher levels. These lower-level data structures must, therefore, encapsulate data from the higher levels.

Data encapsulation

The advantage of these abstractions is that, when programming an application, we only need to consider the highest-level protocol. For example, a web browser needs only to implement the protocols dealing specifically with websites—HTTP, HTML, CSS, and so on. It does not need to bother with implementing TCP/IP, and it certainly doesn't have to understand how an Ethernet or Wi-Fi packet is encoded. It can rely on ready-made implementations of the lower layers for these tasks. These implementations are provided by the operating system (for example, Windows, Linux, and macOS).

When communicating over a network, data must be processed down through the layers at the sender and up again through the layers at the receiver. For example, if we have a web server, Host A, which is transmitting a web page to the receiver, Host B, it may look like this: see diagram

The web page contains a few paragraphs of text, but the web server doesn't only send the text by itself. For the text to be rendered correctly, it must be encoded in an HTML structure: see diagram

In some cases, the text is already preformatted into HTML and saved that way but, in this example, we are considering a web application that dynamically generates the HTML, which is the most common paradigm for dynamic web pages. As the text cannot be transmitted directly, neither can the HTML. It instead must be transmitted as part of an HTTP response. The web server does this by applying the appropriate HTTP response header to the HTML: see diagram

The HTTP is transmitted as part of a TCP session. This isn't done explicitly by the web server, but is taken care of by the operating system's TCP/IP stack: see diagram

The TCP packet is routed by an IP packet: see diagram

This is transmitted over the wire in an Ethernet packet (or another protocol): see diagram

Luckily for us, the lower-level concerns are handled automatically when we use the socket APIs for network programming. It is still useful to know what happens behind the scenes. Without this knowledge, dealing with failures or optimizing for performance is difficult if not impossible.

With some of the theory out of the way, let's dive into the actual protocols powering modern networking.

Internet Protocol

Twenty years ago, there were many competing networking protocols. Today, one protocol is overwhelmingly common—the Internet Protocol. It comes in two versions—IPv4 and IPv6. IPv4 is completely ubiquitous and deployed everywhere. If you're deploying network code today, you must support IPv4 or risk that a significant portion of your users won't be able to connect.

IPv4 uses 32-bit addresses, which limits it to addressing no more than 2^(32) or 4,294,967,296 systems. However, these 4.3 billion addresses were not initially assigned efficiently, and now many Internet Service Providers (ISPs) are forced to ration IPv4 addresses.

IPv6 was designed to replace IPv4 and has been standardized by the Internet Engineering Task Force (IETF) since 1998. It uses a 128-bit address, which allows it to address a theoretical 2^(128) = 340,282,366,920,938,463,463,374,607,431,768,211,456, or about a 3.4 x 10^(38) addresses.

Today, every major desktop and smartphone operating system supports both IPv4 and IPv6 in what is called a dual-stack configuration. However, many applications, servers, and networks are still only configured to use IPv4. From a practical standpoint, this means that you need to support IPv4 in order to access much of the internet. However, you should also support IPv6 to be future-proof and to help the world to transition away from IPv4.

IPv4 addresses are 32 bits long. They are commonly divided into four 8-bit sections. Each section is displayed as a decimal number between 0 and 255 inclusive and is delineated by a period.

Here are some examples of IPv4 addresses:

0.0.0.0, 127.0.0.1, 10.0.0.0, 172.16.0.5, 192.168.0.1, 192.168.50.1, 255.255.255.255

A special address, called the loopback address, is reserved at 127.0.0.1. This address essentially means establish a connection to myself. Operating systems short-circuit this address so that packets sent to it never enter the network but instead stay local on the originating system.

IPv4 reserves some address ranges for private use. If you're using IPv4 through a router/NAT, then you are likely using an IP address in one of these ranges. These reserved private ranges are as follows:

10.0.0.0 to 10.255.255.255
172.16.0.0 to 172.31.255.255
192.168.0.0 to 192.168.255.255

The concept of IP address ranges is a useful one that comes up many times in networking. It's probably not surprising then that there is a shorthand notation for writing them. Using Classless Inter-Domain Routing (CIDR) notation, we can write the three previous address ranges as follows:

10.0.0.0/8
172.16.0.0/12
192.168.0.0/16

CIDR notation works by specifying the number of bits that are fixed. For example, 10.0.0.0/8 specifies that the first eight bits of the 10.0.0.0 address are fixed, the first eight bits being just the first 10. part; the remaining 0.0.0 part of the address can be anything and still be on the 10.0.0.0/8 block. Therefore, 10.0.0.0/8 encompasses 10.0.0.0 through 10.255.255.255.

IPv6 addresses are 128 bits long. They are written as eight groups of four hexadecimal characters delineated by colons. A hexadecimal character can be from 0-9 or from a-f. Here are some examples of IPv6 addresses:

0000:0000:0000:0000:0000:0000:0000:0001
2001:0db8:0000:0000:0000:ff00:0042:8329
fe80:0000:0000:0000:75f4:ac69:5fa7:67f9
ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff

Note that the standard is to use lowercase letters in IPv6 addresses. This is in contrast to many other uses of hexadecimal in computers.

There are a couple of rules for shortening IPv6 addresses to make them easier. Rule 1 allows for the leading zeros in each section to be omitted (for example, 0db8 = db8). Rule 2 allows for consecutive sections of zeros to be replaced with a double colon (::). Rule 2 may only be used once in each address; otherwise, the address would be ambiguous.

Applying both rules, the preceding addresses can be shortened as follows:

::1
2001:db8::ff00:42:8329
fe80::75f4:ac69:5fa7:67f9
ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff

Like IPv4, IPv6 also has a loopback address. It is ::1.

Dual-stack implementations also recognize a special class of IPv6 address that map directly to an IPv4 address. These reserved addresses start with 80 zero bits, and then by 16 one bits, followed by the 32-bit IPv4 address. Using CIDR notation, this block of address is ::ffff:0:0/96.

These mapped addresses are commonly written with the first 96 bits in IPv6 format followed by the remaining 32 bits in IPv4 format. Here are some examples:

IPv6 Address                     Mapped IPv4 Address
::ffff:10.0.0.0                  10.0.0.0
::ffff:172.16.0.5                172.16.0.5
::ffff:192.168.0.1               192.168.0.1
::ffff:192.168.50.1              192.168.50.1

You may also run into IPv6 site-local addresses. These site-local addresses are in the fec0::/10 range and are for use on private local networks. Site-local addresses have now been deprecated and should not be used for new networks, but many existing implementations still use them.

Another address type that you should be familiar with are link-local addresses. Link-local addresses are usable only on the local link. Routers never forward packets from these addresses. They are useful for a system to accesses auto-configuration functions before having an assigned IP address. Link-local addresses are in the IPv4 169.254.0.0/16 address block or the IPv6 fe80::/10 address block.

It should be noted the IPv6 introduces many additional features over IPv4 besides just a greatly expanded address range. IPv6 addresses have new attributes, such as scope and lifetime, and it is normal for IPv6 network interfaces to have multiple IPv6 addresses. IPv6 addresses are used and managed differently than IPv4 addresses.

Domain names

The Internet Protocol can only route packets to an IP address, not a name. So, if you try to connect to a website, such as example.com, your system must first resolve that domain name, example.com, into an IP address for the server that hosts that website.

This is done by connecting to a Domain Name System (DNS) server. You connect to a domain name server by knowing in advance its IP address. The IP address for a domain name server is usually assigned by your ISP.

Many other domain name servers are made publicly available by different organizations.

To resolve a hostname, your computer sends a UDP message to your domain name server and asks it for an AAAA-type record for the domain you're trying to resolve. If this record exists, an IPv6 address is returned. You can then connect to a server at that address to load the website. If no AAAA record exists, then your computer queries the server again, but asks for an A record. If this record exists, you will receive an IPv4 address for the server. In many cases, a site will publish an A record and an AAAA record that route to the same server.

It is also possible, and common, for multiple records of the same type to exist, each pointing to a different address. This is useful for redundancy in the case where multiple servers can provide the same service.

Internet routing

The internet today has an estimated 20 billion devices connected. When you make a connection over the internet, your data first transmits to your local router. From there, it is transmitted to another router, which is connected to another router, and so on. Eventually, your data reaches a router that is connected to the receiving device, at which point, the data has reached its destination: see diagram

Imagine that each router in the preceding diagram is connected to tens, hundreds, or even thousands of other routers and systems. It's an amazing feat that IP can discover the correct path and deliver traffic seamlessly.

Windows includes a utility, tracert, which lists the routers between your system and the destination system. see diagram

The IP addresses are usually listed for many of the intermediate routers, but a few sometimes miss with the 'Request timed out message'. This usually means that the system in question doesn't support the part of the Internet Control Message Protocol (ICMP) protocol needed. It's not unusual to see a few such systems when running tracert.

In Unix-based systems, the utility to trace routes is called traceroute. The information obtained is essentially the same.

Sometimes, when IP packets are transferred between networks, their addresses must be translated. This is especially common when using IPv4. Let's look at the mechanism for this next.

Local networks and address translation

It's common for households and organizations to have small Local Area Networks (LANs). As mentioned previously, there are IPv4 addresses ranges reserved for use in these small local networks. 

These reserved private ranges are as follows:
10.0.0.0 to 10.255.255.255
172.16.0.0 to 172.31.255.255
192.168.0.0 to 192.168.255.255

When a packet originates from a device on an IPv4 local network, it must undergo Network Address Translation (NAT) before being routed on the internet. A router that implements NAT remembers which local address a connection is established from.

The devices on the same LAN can directly address one another by their local address. However, any traffic communicated to the internet must undergo address translation by the router. The router does this by modifying the source IP address from the original private LAN IP address to its public internet IP address: see diagram

Likewise, when the router receives the return communication, it must modify the destination address from its public IP to the private IP of the original sender. It knows the private IP address because it was stored in memory after the first outgoing packet: see diagram

Network address translation can be more complicated than it first appears. In addition to modifying the source IP address in the packet, it must also update the checksums in the packet. Otherwise, the packet would be detected as containing errors and discarded by the next router. The NAT router must also remember which private IP address sent the packet in order to route the reply. Without remembering the translation address, the NAT router wouldn't know where to send the reply to on the private network.

NATs will also modify the packet data in some cases. For example, in the File Transfer Protocol (FTP), some connection information is sent as part of the packet's data. In these cases, the NAT router will look at the packet's data in order to know how to forward future incoming packets. IPv6 largely avoids the need for NAT, as it is possible (and common) for each device to have its own publicly-addressable address.

You may be wondering how a router knows whether a message is locally deliverable or whether it must be forwarded. This is done using a netmask, subnet mask, or CIDR.

Subnetting and CIDR

IP addresses can be split into parts. The most significant bits are used to identify the network or subnetwork, and the least significant bits are used to identify the specific device on the network.

IPv4 traditionally uses a mask notation to identify the IP address parts. For example, consider a router on the 10.0.0.0 network with a subnet mask of 255.255.255.0. This router can take any incoming packet and perform a bitwise AND operation with the subnet mask to determine whether the packet belongs on the local subnet or needs to be forwarded on. For example, this router receives a packet to be delivered to 10.0.0.105. It does a bitwise AND operation on this address with the subnet mask of 255.255.255.0, which produces 10.0.0.0. That matches the subnet of the router, so the traffic is local. If, instead, we consider a packet destined for 10.0.15.22, the result of the bitwise AND with the subnet mask is 10.0.15.0. This address doesn't match the subnet the router is on, and so it must be forwarded.

IPv6 uses CIDR. Networks and subnetworks are specified using the CIDR notation we described earlier. For example, if the IPv6 subnet is /112, then the router knows that any address that matches on the first 112 bits is on the local subnet.

So far, we've covered only routing with one sender and one receiver. While this is the most common situation, let's consider alternative cases too.

Multicast, broadcast, and anycast

When a packet is routed from one sender to one receiver, it uses unicast addressing. This is the simplest and most common type of addressing. All of the protocols we deal with in this book use unicast addressing.

Broadcast addressing allows a single sender to address a packet to all recipients simultaneously. It is typically used to deliver a packet to every receiver on an entire subnet.

If a broadcast is a one-to-all communication, then multicast is a one-to-many communication. Multicast involves some group management, and a message is addressed and delivered to members of a group.

Anycast addressed packets are used to deliver a message to one recipient when you don't care who that recipient is. This is useful if you have several servers that provide the same functionality, and you simply want one of them (you don't care which) to handle your request.

IPv4 and lower network levels support local broadcast addressing. IPv4 provides some optional (but commonly implemented) support for multicasting. IPv6 mandates multicasting support while providing additional features over IPv4's multicasting. Though IPv6 is not considered to broadcast, its multicasting functionality can essentially emulate it.

It's worth noting that these alternative addressing methods don't generally work over the broader internet. Imagine if one peer was able to broadcast a packet to every connected internet device. It would be a mess!

If you can use IP multicasting on your local network, though, it is worthwhile to implement it. Sending one IP level multicast conserves bandwidth compared to sending the same unicast message multiple times.

However, multicasting is often done at the application level. That is, when the application wants to deliver the same message to several recipients, it sends the message multiple times – once to each recipient.

We've covered how messages are routed through a network. Now, let's see how a message knows which application is responsible for it once it arrives at a specific system.

Port numbers

An IP address alone isn't quite enough. We need port numbers. To return to the telephone analogy, if IP addresses are phone numbers, then port numbers are like phone extensions. Generally, an IP address gets a packet routed to a specific system, but a port number is used to route the packet to a specific application on that system.

For example, on your system, you may be running multiple web browsers, an email client, and a video-conferencing client. When your computer receives a TCP segment or UDP datagram, your operating system looks at the destination port number in that packet. That port number is used to look up which application should handle it.

Port numbers are stored as unsigned 16-bit integers. This means that they are between 0 and 65,535 inclusive.

Some port numbers for common protocols are as follows:

Port Number             Protocol
20, 21          TCP     File Transfer Protocol (FTP)
22              TCP     Secure Shell (SSH)
23              TCP     Telnet
25              TCP     Simple Mail Transfer Protocol (SMTP)
53              UDP     Domain Name System (DNS)
80              TCP     Hypertext Transfer Protocol (HTTP)
110             TCP     Post Office Protocol, Version 3 (POP3)
143             TCP     Internet Message Access Protocol(IMAP)
194             TCP     Internet Relay Chat (IRC)
443             TCP     HTTP over TLS/SSL (HTTPS)
993             TCP     IMAP over TLS/SSL (IMAPS)
995             TCP     POP3 over TLS/SSL (POP3S)

Each of these listed port numbers is assigned by the Internet Assigned Numbers Authority (IANA). They are responsible for the official assignments of port numbers for specific protocols. Unofficial port usage is very common for applications implementing custom protocols. In this case, the application should try to choose a port number that is not in common use to avoid conflict.

Clients and servers

In the telephone analogy, a call must be initiated first by one party. The initiating party dials the number for the receiving party, and the receiving party answers.
This is also a common paradigm in networking called the client-server model. In this model, a server listens for connections. The client, knowing the address and port number that the server is listening on, establishes the connection by sending the first packet.
For example, the web server at example.com listens on port 80 (HTTP) and port 443 (HTTPS). A web browser (client) must establish the connection by sending the first packet to the web server address and port.

Putting it together

A socket is one end-point of a communication link between systems. It's an abstraction in which your application can send and receive data over the network, in much the same way that your application can read and write to a file using a file handle.

An open socket is uniquely defined by a 5-tuple item consisting of the following:

Local IP address
Local port
Remote IP address
Remote port
Protocol (UDP or TCP)

This 5-tuple is important, as it is how your operating system knows which application is responsible for any packets received. For example, if you use two web browsers to establish two simultaneous connections to example.com on port 80, then your operating system keeps the connections separate by looking at the local IP address, local port, remote IP address, remote port, and protocol. In this case, the local IP addresses, remote IP addresses, remote port (80), and protocol (TCP) are identical.

The deciding factor then is the local port (also called the ephemeral port), which will have been chosen to be different by the operating system for connection. This 5-tuple is also important to understand how NAT works. A private network may have many systems accessing the same outside resource, and the router NAT must store this five tuple for each connection in order to know how to route received packets back into the private network.

What's your address?

You can find your IP address using the ipconfig command on Windows, or the ifconfig command on Unix-based systems (such as Linux and macOS).

On Unix-based systems, we use either the ifconfig or ip addr commands. The ifconfig command is the old way and is now deprecated on some systems. The ip addr command is the new way, but not all systems support it yet.

If you are behind a NAT, there is often no good way to know your public IP address. Usually, the only resort is to contact an internet server that provides an API that informs you of your IP address.

A few free and public APIs for this are as follows:

http://api.ipify.org/
http://icanhazip.com/
http://ifconfig.me/ip

Now that we've seen the built-in utilities for determining our local IP addresses, let's next look at how to accomplish this from C.

Listing network adapters from C

Sometimes, it is useful for your C programs to know what your local address is. For most of this book, we are able to write code that works both on Windows and Unix-based (Linux and macOS) systems. However, the API for listing local addresses is very different between systems. For this reason, we split this program into two: one for Windows and one for Unix-based systems.

We will address the Windows case first. Please see win_list.c program in Code-and-IAC/C/listing-network-adapters-windows

Now that we can list local IP addresses on Windows, let's consider the same task for Unix-based systems.

Listing network adapters on Linux and macOS: Listing local network addresses is somewhat easier on a Unix-based system, compared to Windows. See unix_list.c in Code-and-IAC/C/listing-network-adapters-linux-macos

questions:

What are the key differences between IPv4 and IPv6?

IPv4 only supports 4 billion unique addresses, and because they were allocated inefficiently, we are now running out. IPv6 supports 3.4 x 10^38 possible addresses. IPv6 provides many other improvements, but this is the one that affects our network programming directly.

Are the IP addresses given by the ipconfig and ifconfig commands the same IP addresses that a remote web server sees if you connect to it?

Sometimes, these addresses will match, but not always. If you're on a private IPv4 network, then your router likely performs network address translation. The remote web server then sees the translated address.
If you have a publicly routable IPv4 or IPv6 address, then the address seen by the remote web server will match those reported by ipconfig and ifconfig.

What is the IPv4 loopback address?

The IPv4 loopback address is 127.0.0.1, and it allows networked programs to communicate with each other while executing on the same machine.

What is the IPv6 loopback address?

The IPv6 loopback address is ::1. It works in the same way as the IPv4 loopback address.

How are domain names (for example, example.com) resolved into IP addresses?

DNS is used to resolve domain names into IP addresses. 

How can you find your public IP address?

The easiest way is to visit a website that reports it for you.

How does an operating system know which application is responsible for an incoming packet?

Each IP packet has a local address, remote address, local port number, remote port number, and protocol type. These five attributes are memorized by the operating system to determine which application should handle any given incoming packet.

----

chapter 2

what are sockets? a socket is one endpoint of a communication link between end systems (hosts). Your applications sends and receives all of its network data through a socket.

There are a few different socket application programming interfaces (APIs). The first were Berkeley sockets, which were released in 1983 with 4.3BSD Unix. The Berkeley socket API was widely successful and quickly evolved into a de facto standard. From there, it was adopted as a POSIX standard with little modification. The terms Berkeley sockets, BSD sockets, Unix sockets, and Portable Operating System Interface (POSIX) sockets are often used interchangeably.

If you're using Linux or macOS, then your operating system provides a proper implementation of Berkeley sockets.

Windows' socket API is called Winsock. It was created to be largely compatible with Berkeley sockets.

Historically, sockets were used for inter-process communication (IPC) as well as various network protocols. In this book, we use sockets only for communication with TCP and UDP.

Before we can use the socket API, we need to include the socket API header files. These files vary depending on whether we are using Berkeley sockets or Winsock. Additionally, Winsock requires initialization before use. It also requires that a cleanup function is called when we are finished. These initialization and cleanup steps are not used with Berkeley sockets.

We will use the C preprocessor to run the proper code on Windows compared to Berkeley socket systems. By using the preprocessor statement, #if defined(_WIN32), we can include code in our program that will only be compiled on Windows.

A complete program that includes the needed socket API headers for each platform and properly initializes Winsock on Windows can be found in Code-and-IAC/C/listing-network-adapters-all

Now that we've done the necessary setup to begin using the socket APIs, let's take a closer look at what we will be using these sockets for.

Two types of sockets

Sockets come in two basic types — connection-oriented and connectionless. These terms refer to types of protocols. Beginners sometimes get confused with the term connectionless. Of course, two systems communicating over a network are in some sense connected. Keep in mind that these terms are used with special meanings, which we will cover shortly, and should not imply that some protocols manage to send data without a connection.

The two protocols that are used today are Transmission Control Protocol (TCP) and User Datagram Protocol (UDP). TCP is a connection-oriented protocol, and UDP is a connectionless protocol.

The socket APIs also support other less-common or outdated protocols, which we do not cover in this book.

In a connectionless protocol, such as UDP, each data packet is addressed individually. From the protocol's perspective, each data packet is completely independent and unrelated to any packets coming before or after it.

A good analogy for UDP is postcards. When you send a postcard, there is no guarantee that it will arrive. There is also no way to know if it did arrive. If you send many postcards at once, there is no way to predict what order they will arrive in. It is entirely possible that the first postcard you send gets delayed and arrives weeks after the last postcard was sent.

With UDP, these same caveats apply. UDP makes no guarantee that a packet will arrive. UDP doesn't generally provide a method to know if a packet did not arrive, and UDP does not guarantee that the packets will arrive in the same order they were sent. As you can see, UDP is no more reliable than postcards. In fact, you may consider it less reliable, because with UDP, it is possible that a single packet may arrive twice!

If you need reliable communication, you may be tempted to develop a scheme where you number each packet that's sent. For the first packet sent, you number it one, the second packet sent is numbered two, and so on. You could also request that the receiver send an acknowledgment for each packet. When the receiver gets packet one, it sends a return message, packet one received. In this way, the receiver can be sure that received packets are in the proper order. If the same packet arrives twice, the receiver can just ignore the redundant copy. If a packet isn't received at all, the sender knows from the missing acknowledgment and can resend it.

This scheme is essentially what connection-oriented protocols, such as TCP, do. TCP guarantees that data arrives in the same order it is sent. It prevents duplicate data from arriving twice, and it retries sending missing data. It also provides additional features such as notifications when a connection is terminated and algorithms to mitigate network congestion. Furthermore, TCP implements these features with an efficiency that is not achievable by piggybacking a custom reliability scheme on top of UDP.

For these reasons, TCP is used by many protocols. HTTP (for serving web pages), FTP (for transferring files), SSH (for remote administration), and SMTP (for delivering email) all use TCP. We will cover HTTP, SSH, and SMTP in the coming chapters.

UDP is used by DNS (for resolving domain names). It is suitable for this purpose because an entire request and response can fit in a single packet.

UDP is also commonly used in real-time applications, such as audio streaming, video streaming, and multiplayer video games. In real-time applications, there is often no reason to retry sending dropped packets, so TCP's guarantees are unnecessary. For example, if you are streaming live video and a few packets get dropped, the video simply resumes when the next packet arrives. There is no reason to resend (or even detect) the dropped packet, as the video has already progressed past that point.

UDP also has the advantage in cases where you want to send a message without expecting a response from the other end. This makes it useful when using IP broadcast or multicast. TCP, on the other hand, requires bidirectional communication to provide its guarantees, and TCP does not work with IP multicast or broadcast.

If the guarantees that TCP provides are not needed, then UDP can achieve greater efficiency. This is because TCP adds some additional overhead by numbering packets. TCP must also delay packets that arrive out of order, which can cause unnecessary delays in real-time applications. If you do need the guarantees provided by TCP, however, it is almost always preferable to use TCP instead of trying to add those mechanisms to UDP.

Now that we have an idea of the communication models we use sockets for, let's look at the actual functions that are used in socket programming.

Socket functions

The socket APIs provide many functions for use in network programming. Here are the common socket functions that we use in this book:

1. socket() creates and initializes a new socket.
2. bind() associates a socket with a particular local IP address and port number.
3. listen() is used on the server to cause a TCP socket to listen for new connections.
4. connect() is used on the client to set the remote address and port. In the case of TCP, it also establishes a connection.
5. accept() is used on the server to create a new socket for an incoming TCP connection.
6. send() and recv() are used to send and receive data with a socket.
7. sendto() and recvfrom() are used to send and receive data from sockets without a bound remote address.
8. close() (Berkeley sockets) and closesocket() (Winsock sockets) are used to close a socket. In the case of TCP, this also terminates the connection.
9. shutdown() is used to close one side of a TCP connection. It is useful to ensure an orderly connection teardown.
10. select() is used to wait for an event on one or more sockets.
11. getnameinfo() and getaddrinfo() provide a protocol-independent manner of working with hostnames and addresses.
12. setsockopt() is used to change some socket options.
13. fcntl() (Berkeley sockets) and ioctlsocket() (Winsock sockets) are also used to get and set some socket options.

You may see some Berkeley socket networking programs using read() and write(). These functions don't port to Winsock, so we prefer send() and recv() here. Some other common functions that are used with Berkeley sockets are poll() and dup(). We will avoid these in order to keep our programs portable.

Now that we have an idea of the functions involved, let's consider program design and flow next.

Anatomy of a socket program

Network programming is usually done using a client-server paradigm. In this paradigm, a server listens for new connections at a published address. The client, knowing the server's address, is the one to establish the connection initially. Once the connection is established, the client and the server can both send and receive data. This can continue until either the client or the server terminates the connection.

A traditional client-server model usually implies different behaviors for the client and server. The way web browsing works, for example, is that the server resides at a known address, waiting for connections. A client (web browser) establishes a connection and sends a request that includes which web page or resource it wants to download. The server then checks that it knows what to do with this request and responds appropriately (by sending the web page).

An alternative paradigm is the peer-to-peer model. For example, this model is used by the BitTorrent protocol. In the peer-to-peer model, each peer has essentially the same responsibilities. While a web server is optimized to send requested data from the server to the client, a peer-to-peer protocol is balanced in that data is exchanged somewhat evenly between peers. However, even in the peer-to-peer model, the underlying sockets that are using TCP or UDP aren't created equal. That is, for each peer-to-peer connection, one peer was listening and the other connecting. BitTorrent works by having a central server (called a tracker) that stores a list of peer IP addresses. Each of the peers on that list has agreed to behave like a server and listen for new connections. When a new peer wants to join the swarm, it requests a list of peers from the central server, and then tries to establish a connection to peers on that list while simultaneously listening for new connections from other peers. In summary, a peer-to-peer protocol doesn't so much replace the client-server model; it is just expected that each peer be a client and a server.

Another common protocol that pushes the boundary of the client-server paradigm is FTP. The FTP server listens for connections until the FTP client connects. After the initial connection, the FTP client issues commands to the server. If the FTP client requests a file from the server, the server will attempt to establish a new connection to the FTP client to transfer the file over. So, for this reason, the FTP client first establishes a connection as a TCP client, but later accepts connections like a TCP server.

Network programs can usually be described as one of four types—a TCP server, a TCP client, a UDP server, or a UDP client. Some protocols call for a program to implement two, or even all four types, but it is useful for us to consider each of the four types separately.

TCP program flow

A TCP client program must first know the TCP server's address. This is often input by a user. In the case of a web browser, the server address is either input directly by the user into the address bar, or is known from the user clicking on a link. The TCP client takes this address (for example, http://example.com) and uses the getaddrinfo() function to resolve it into a struct addrinfo structure. The client then creates a socket using a call to socket(). The client then establishes the new TCP connection by calling connect(). At this point, the client can freely exchange data using send() and recv().

A TCP server listens for connections at a particular port number on a particular interface. The program must first initialize a struct addrinfo structure with the proper listening IP address and port number. The getaddrinfo() function is helpful so that you can do this in an IPv4/IPv6 independent way. The server then creates the socket with a call to socket(). The socket must be bound to the listening IP address and port. This is accomplished with a call to bind().

The server program then calls listen(), which puts the socket in a state where it listens for new connections. The server can then call accept(), which will wait until a client establishes a connection to the server. When the new connection has been established, accept() returns a new socket. This new socket can be used to exchange data with the client using send() and recv(). Meanwhile, the first socket remains listening for new connections, and repeated calls to accept() allow the server to handle multiple clients.

Graphically, the program flow of a TCP client and server looks like this: see diagram

The program flow given here should serve as a good example of how basic client-server TCP programs interact. That said, considerable variation on this basic program flow is possible. There is also no rule about which side calls send() or recv() first, or how many times. Both sides could call send() as soon as the connection is established.

Also, note that the TCP client could call bind() before connect() if it is particular about which network interface is being used to connect with. This is sometimes important on servers that have multiple network interfaces. It's often not important for general purpose software.

UDP program flow

A UDP client must know the address of the remote UDP peer in order to send the first packet. The UDP client uses the getaddrinfo() function to resolve the address into a struct addrinfo structure. Once this is done, the client creates a socket of the proper type. The client can then call sendto() on the socket to send the first packet. The client can continue to call sendto() and recvfrom() on the socket to send and receive additional packets. Note that the client must send the first packet with sendto(). The UDP client cannot receive data first, as the remote peer would have no way of knowing where to send data without it first receiving data from the client. This is different from TCP, where a connection is first established with a handshake. In TCP, either the client or server can send the first application data.

A UDP server listens for connections from a UDP client. This server should initialize struct addrinfo structure with the proper listening IP address and port number. The getaddrinfo() function can be used to do this in a protocol-independent way. The server then creates a new socket with socket() and binds it to the listening IP address and port number using bind(). At this point, the server can call recvfrom(), which causes it to block until it receives data from a UDP client. After the first data is received, the server can reply with sendto() or listen for more data (from the first client or any new client) with recvfrom().

Graphically, the program flow of a UDP client and server looks like this: see diagram

We're almost ready to begin implementing our first networked program, but before we begin, we should take care of some cross-platform concerns. Let's work on this now.

Berkeley sockets versus Winsock sockets

As we stated earlier, Winsock sockets were modeled on Berkeley sockets. Therefore, there are many similarities between them. However, there are also many differences we need to be aware of.

In this book, we will try to create each program so that it can run on both Windows and Unix-based operating systems. This is made much easier by defining a few C macros to help us with this.

Header files

As we mentioned earlier, the needed header files differ between implementations. We've already seen how these header file discrepancies can be easily overcome with a preprocessor statement.

Socket data type

In UNIX, a socket descriptor is represented by a standard file descriptor. This means you can use any of the standard UNIX file I/O functions on sockets. This isn't true on Windows, so we simply avoid these functions to maintain portability.

Additionally, in UNIX, all file descriptors (and therefore socket descriptors) are small, non-negative integers. In Windows, a socket handle can be anything. Furthermore, in UNIX, the socket() function returns an int, whereas in Windows it returns a SOCKET. SOCKET is a typedef for an unsigned int in the Winsock headers. As a workaround, I find it useful to either typedef int SOCKET or #define SOCKET int on non-Windows platforms. That way, you can store a socket descriptor as a SOCKET type on all platforms:

#if !defined(_WIN32) 
#define SOCKET int 
#endif

Invalid sockets

On Windows, socket() returns INVALID_SOCKET if it fails. On Unix, socket() returns a negative number on failure. This is particularly problematic as the Windows SOCKET type is unsigned. I find it useful to define a macro to indicate if a socket descriptor is valid or not:

#if defined(_WIN32)
#define ISVALIDSOCKET(s) ((s) != INVALID_SOCKET) 
#else
#define ISVALIDSOCKET(s) ((s) >= 0) 
#endif

Closing sockets

All sockets on Unix systems are also standard file descriptors. For this reason, sockets on Unix systems can be closed using the standard close() function. On Windows, a special close function is used instead—closesocket(). It's useful to abstract out this difference with a macro:

#if defined(_WIN32)
#define CLOSESOCKET(s) closesocket(s) 
#else
#define CLOSESOCKET(s) close(s) 
#endif

Error handling

When a socket function, such as socket(), bind(), accept(), and so on, has an error on a Unix platform, the error number gets stored in the thread-global errno variable. On Windows, the error number can be retrieved by calling WSAGetLastError() instead. Again, we can abstract out this difference using a macro:

#if defined(_WIN32)
#define GETSOCKETERRNO() (WSAGetLastError())
#else
#define GETSOCKETERRNO() (errno)
#endif

With these helper macros out of the way, let's dive into our first real socket program.

Our first program

Now that we have a basic idea of socket APIs and the structure of networked programs, we are ready to begin our first program. By building an actual real-world program, we will learn the useful details of how socket programming actually works.

As an example task, we are going to build a web server that tells you what time it is right now. This could be a useful resource for anybody with a smartphone or web browser that needs to know what time it is right now. They can simply navigate to our web page and find out. This is a good first example because it does something useful but still trivial enough that it won't distract from what we are trying to learn—network programming.

A motivating example

Before we begin the networked program, it is useful to solve our problem with a simple console program first. In general, it is a good idea to work out your program's functionality locally before adding in networked features.
The local, console version of our time-telling program is as follows: see /Users/robertndungu/Documents/Computing/Code-and-IAC/C/local time

Making it networked

To see the functionality of the time program above networked see /Users/robertndungu/Documents/Computing/Code-and-IAC/C/time server

working with ipv6

Please recall the hints.ai_family = AF_INET part of time_server.c near the beginning of the main() function. If this line is changed to hints.ai_family = AF_INET6, then your web server listens for IPv6 connections instead of IPv4 connections. This modified file is included in the GitHub repository as time_server_ipv6.c.

In this case, you should navigate your web browser to http://[::1]:8080 to see the web page. ::1 is the IPv6 loopback address, which tells the web browser to connect to the same machine it's running on. In order to use IPv6 addresses in URLs, you need to put them in square brackets, []. :8080 specifies the port number in the same way that we did for the IPv4 example.

Supporting both IPv4 and IPv6

It is also possible for the listening IPv6 socket to accept IPv4 connections with a dual-stack socket. Not all operating systems support dual-stack sockets. With Linux in particular, support varies between distros. If your operating system does support dual-stack sockets, then I highly recommend implementing your server programs using this feature. It allows your programs to communicate with both IPv4 and IPv6 peers while requiring no extra work on your part.

We can modify time_server_ipv6.c to use dual-stack sockets with only a minor addition. After the call to socket() and before the call to bind(), we must clear the IPV6_V6ONLY flag on the socket. This is done with the setsockopt() function:

/*time_server_dual.c excerpt*/

int option = 0;

if (setsockopt(socket_listen, IPPROTO_IPV6, IPV6_V6ONLY, (void*)&option, sizeof(option)))
{
    fprintf(stderr, "setsockopt() failed. (%d)\n", GETSOCKETERRNO());
    return 1;
}

We first declare option as an integer and set it to 0. IPV6_V6ONLY is enabled by default, so we clear it by setting it to 0. setsockopt() is called on the listening socket. We pass in IPPROTO_IPV6 to tell it what part of the socket we're operating on, and we pass in IPV6_V6ONLY to tell it which flag we are setting. We then pass in a pointer to our option and its length. setsockopt() returns 0 on success.

Windows Vista and later supports dual-stack sockets. However, many Windows headers are missing the definitions for IPV6_V6ONLY. For this reason, it might make sense to include the following code snippet at the top of the file:

/*time_server_dual.c excerpt*/

#if !defined(IPV6_V6ONLY)
#define IPV6_V6ONLY 27
#endif

Keep in mind that the socket needs to be initially created as an IPv6 socket. This is accomplished with the hints.ai_family = AF_INET6 line in our code. When an IPv4 peer connects to our dual-stack server, the connection is remapped to an IPv6 connection. This happens automatically and is taken care of by the operating system. When your program sees the client IP address, it will still be presented as a special IPv6 address. These are represented by IPv6 addresses where the first 96 bits consist of the prefix—0:0:0:0:0:ffff. The last 32 bits of the address are used to store the IPv4 address. For example, if a client connects with the IPv4 address 192.168.2.107, then your dual-stack server sees it as the IPv6 address ::ffff:192.168.2.107.

Networking with inetd

On Unix-like systems, such as Linux or macOS, a service called inetd can be used to turn console-only applications into networked ones. You can configure inetd (with /etc/inetd.conf) with your program's location, port number, protocol (TCP or UDP), and the user you want it to run as. inetd will then listen for connections on your desired port. After an incoming connection is accepted by inetd, it will start your program and redirect all socket input/output through stdin and stdout.
what is a console only application? is a computer program designed to be used via a text only computer interface. These applications typically run in a command line interface or terminal and do not have a GUI option.

Using inetd, we could have time_console.c behave like time_server.c with very minimal changes. We would only need to add in an extra printf() function with the HTTP response header, read from stdin, and configure inetd.

You may be able to use inetd on Windows through Cygwin or the Windows Subsystem for Linux.

questions:

1. What is a socket? is one endpoint of a communication link between systems; it is an abstraction in which your application can send and receive data over the network

2. what is a connectionless protocol? used by the UDP protocol where each data packet is addressed individually. Each data packet is completely independent and unrelated to any packets coming before or after it

what is a connection oriented protocol? Used by the Tcp protocol; guarantees that data arrives in the same order that it was sent whilst preventing duplicate data from arriving twice and resending missing data. It also provides notifications when a connection is terminated and algorithms to mitigate network congestion

3. Is UDP a connectionless or connection-oriented protocol? connectionless protocol

4. Is TCP a connectionless or connection-oriented protocol? connection-oriented protocol

5. What types of applications generally benefit from using the UDP protocol? real time applications and simple protocols like DNS

6. What types of applications generally benefit from using the TCP protocol? those that guaranteed data delivery, error checking, and flow control

7. Does TCP guarantee that data will be transmitted successfully? yes

8. What are some of the main differences between Berkeley sockets and Winsock sockets? initialisation and cleanup process required when using the Winsock windows API. This is not required when using berkley sockets. The header files used also differ between the two APIs; although they do have common ones between them. there exist some function name differences eg close() function in berkley sockets is replaced by closesocket() in winsock.

9. What does the bind() function do? after a socket has been created, a call to bind() is made to associate the socket with the local address obtained from calling getaddrinfo()

10. What does the accept() function do? is used to accept any incoming connections, it creates a new socket for the accepted connection. It also fills in the address info of the client that connected

11. In a TCP connection, does the client or the server send application data first? could be either


C. An indepth overview of TCP connections

Multiplexing TCP connections

The socket APIs are blocking by default. When you use accept() to wait for an incoming connection, your program's execution is blocked until a new incoming connection is actually available. When you use recv() to read incoming data, your program's execution blocks until new data is actually available.

In the last chapter, we built a simple TCP server. This server only accepted one connection, and it only read data from that connection once. Blocking wasn't a problem then, because our server had no other purpose than to serve its one and only client.

In the general case, though, blocking I/O can be a significant problem. Imagine that our server from Chapter 2, Getting to Grips with Socket APIs, needed to serve multiple clients. Then, imagine that one slow client connected to it. Maybe this slow client takes a minute before sending its first data. During this minute, our server would simply be waiting on the recv() call to return. If other clients were trying to connect, they would have to wait it out.

Blocking on recv() like this isn't really acceptable. A real application usually needs to be able to manage several connections simultaneously. This is obviously true on the server side, as most servers are built to manage many connected clients. Imagine running a website where hundreds of clients are connected at once. Serving these clients one at a time would be a non-starter.

Blocking also isn't usually acceptable on the client side either. If you imagine building a fast web browser, it needs to be able to download many images, scripts, and other resources in parallel. Modern web browsers also have a tab feature where many whole web pages can be loaded in parallel.

What we need is a technique for handling many separate connections simultaneously.

Polling non-blocking sockets

It is possible to configure sockets to use a non-blocking operation. One way to do this is by calling fcntl() with the O_NONBLOCK flag (ioctlsocket() with the FIONBIO flag on Windows), although other ways also exist. Once in non-blocking mode, a call to recv() with no data will return immediately. See Chapter 13, Socket Programming Tips and Pitfalls, for more information.

A program structured with this in mind could simply check each of its active sockets in turn, continuously. It would handle any socket that returned data and ignore any socket that didn't. This is called polling. Polling can be a waste of computer resources since most of the time, there will be no data to read. It also complicates the program somewhat, as the programmer is required to manually track which sockets are active and which state, they are in. Return values from recv() must also be handled differently than with blocking sockets. For these reasons, we won't use polling in this book.

Forking and multithreading

Another possible solution to multiplexing socket connections is to start a new thread or process for each connection. In this case, blocking sockets are fine, as they block only their servicing thread/process, and they do not block other threads/processes. This can be a useful technique, but it also has some downsides. First of all, threading is tricky to get right. This is especially true if the connections must share any state between them. It is also less portable as each operating system provides a different API for these features.

On Unix-based systems, such as Linux and macOS, starting a new process is very easy. We simply use the fork() function. The fork() function splits the executing program into two separate processes. A multi-process TCP server may accept connections like this:

while(1) {
    socket_client = accept(socket_listen, &new_client, &new_client_length);     
    int pid = fork();
    if (pid == 0) { //child process
        close(socket_listen);
        recv(socket_client, ...);
        send(socket_client, ...);
        close(socket_client);
        exit(0);
    }
    //parent process
    close(socket_client);
}

In this example, the program blocks on accept(). When a new connection is established, the program calls fork() to split into two processes. The child process, where pid == 0, only services this one connection. Therefore, the child process can use recv() freely without worrying about blocking. The parent process simply calls close() on the new connection and returns to listening for more connections with accept().

Using multiple processes/threads is much more complicated on Windows. Windows provides CreateProcess(), CreateThread(), and many other functions for these features. However—and I can say this objectively—they are all much harder to use than Unix's fork().

Debugging these multi-process/thread programs can be much more difficult compared to the single process case. Communicating between sockets and managing shared state is also much more burdensome. For these reasons, we will avoid fork() and other multiprocess/thread techniques for the rest of this book.

That being said, an example TCP server using fork is included in this chapter's code. It's named tcp_serve_toupper_fork.c. It does not run on Windows, but it should compile and run cleanly on Linux and macOS. I would suggest finishing the rest of this chapter before looking at it.

The select() function

Our preferred technique for multiplexing is to use the select() function. We can give select() a set of sockets, and it tells us which ones are ready to be read. It can also tell us which sockets are ready to write to and which sockets have exceptions. Furthermore, it is supported by both Berkeley sockets and Winsock. Using select() keeps our programs portable.

Synchronous multiplexing with select()

The select() function has several useful features. Given a set of sockets, it can be used to block until any of the sockets in that set is ready to be read from. It can also be configured to return if a socket is ready to be written to or if a socket has an error. Additionally, we can configure select() to return after a specified time if none of these events take place.

The C function prototype for select() is as follows:

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

Before calling select(), we must first add our sockets into an fd_set. If we have three sockets, socket_listen, socket_a, and socket_b, we add them to an fd_set, like this:

fd_set our_sockets;
FD_ZERO(&our_sockets);
FD_SET(socket_listen, &our_sockets);
FD_SET(socket_a, &our_sockets);
FD_SET(socket_b, &our_sockets);

It is important to zero-out the fd_set using FD_ZERO() before use.

Socket descriptors are then added to the fd_set one at a time using FD_SET(). A socket can be removed from an fd_set using FD_CLR(), and we can check for the presence of a socket in the set using FD_ISSET().

You may see some programs manipulating an fd_set directly. I recommend that you use only FD_ZERO(), FD_SET(), FD_CLR(), and FD_ISSET() to maintain portability between Berkeley sockets and Winsock.

select() also requires that we pass a number that's larger than the largest socket descriptor we are going to monitor. (This parameter is ignored on Windows, but we will always do it anyway for portability.) We store the largest socket descriptor in a variable, like this:

SOCKET max_socket;
max_socket = socket_listen;
if (socket_a > max_socket) max_socket = socket_a;
if (socket_b > max_socket) max_socket = socket_b;

When we call select(), it modifies our fd_set of sockets to indicate which sockets are ready. For that reason, we want to copy our socket set before calling it. We can copy an fd_set with a simple assignment like this, and then call select() like this:

fd_set copy;
copy = our_sockets;
select(max_socket+1, &copy, 0, 0, 0);

This call blocks until at least one of the sockets is ready to be read from. When select() returns, copy is modified so that it only contains the sockets that are ready to be read from. We can check which sockets are still in copy using FD_ISSET(), like this:

if (FD_ISSET(socket_listen, &copy)) {
    //socket_listen has a new connection
    accept(socket_listen...
}
if (FD_ISSET(socket_a, &copy)) {
    //socket_a is ready to be read from
    recv(socket_a...
}
if (FD_ISSET(socket_b, &copy)) {
    //socket_b is ready to be read from
    recv(socket_b...
}

In the previous example, we passed our fd_set as the second argument to select(). If we wanted to monitor an fd_set for writability instead of readability, we would pass our fd_set as the third argument to select(). Likewise, we can monitor a set of sockets for exceptions by passing it as the fourth argument to select().

select() timeout

The last argument taken by select() allows us to specify a timeout. It expects a pointer to struct timeval. The timeval structure is declared as follows:

struct timeval {     
    long tv_sec;     
    long tv_usec; 
}

tv_sec holds the number of seconds, and tv_usec holds the number of microseconds (1,000,000th second). If we want select() to wait a maximum of 1.5 seconds, we can call it like this:

struct timeval timeout;
timeout.tv_sec = 1;
timeout.tv_usec = 500000;
select(max_socket+1, &copy, 0, 0, &timeout);

In this case, select() returns after a socket in fd_set copy is ready to read or after 1.5 seconds has elapsed, whichever is sooner.

If timeout.tv_sec = 0 and timeout.tv_usec = 0, then select() returns immediately (after changing the fd_set as appropriate). As we saw previously, if we pass in a null pointer for the timeout parameter, then select() does not return until at least one socket is ready to be read.

select() can also be used to monitor for writeable sockets (sockets where we could call send() without blocking), and sockets with exceptions. We can check for all three conditions with one call:

select(max_sockets+1, &ready_to_read, &ready_to_write, &excepted, &timeout);

On success, select() itself returns the number of socket descriptors contained in the (up to) three descriptor sets it monitored. The return value is zero if it timed out before any sockets were readable/writeable/excepted. select() returns -1 to indicate an error.

Iterating through an fd_set

We can iterate through an fd_set using a simple for loop. Essentially, we start at 1, since all socket descriptors are positive numbers, and we continue through to the largest known socket descriptor in the set. For each possible socket descriptor, we simply use FD_ISSET() to check if it is in the set. If we wanted to call CLOSESOCKET() for every socket in the fd_set master, we could do it like this:

SOCKET i;
for (i = 1; i <= max_socket; ++i) {
    if (FD_ISSSET(i, &master)) {
        CLOSESOCKET(i);
    }
}

This may seem like a brute-force approach, and it actually kind of is. However, these are the tools that we have to work with. FD_ISSET() runs very fast, and it's likely that processor time spent on other socket operations will dwarf what time was spent iterating through them in this manner. Nevertheless, you may be able to optimize this operation by additionally storing your sockets in an array or linked list. I don't recommend that you make this optimization unless you profile your code and find the simple for loop iteration to be a significant bottleneck.

select() on non-sockets

On Unix-based systems, select() can also be used on file and terminal I/O, which can be extremely useful. This doesn't work on Windows, though. Windows only supports select() for sockets.

A TCP client

It will be useful for us to have a TCP client that can connect to any TCP server. This TCP client will take in a hostname (or IP address) and port number from the command line. It will attempt a connection to the TCP server at that address. If successful, it will relay data that's received from that server to the terminal and data inputted into the terminal to the server. It will continue until either it is terminated (with Ctrl + C) or the server closes the connection.

This is useful as a learning opportunity to see how to program a TCP client, but it is also useful for testing the TCP server programs we develop throughout this book.

Our basic program flow looks like this: tcp_client_flow.png

Our program first uses getaddrinfo() to resolve the server address from the command-line arguments. Then, the socket is created with a call to socket(). The fresh socket has connect() called on it to connect to the server. We use select() to monitor for socket input. select() also monitors for terminal/keyboard input on non-Windows systems. On Windows, we use the _kbhit() function to detect terminal input. If terminal input is available, we send it over the socket using send(). If select() indicated that socket data is available, we read it with recv() and display it to the terminal. This select() loop is repeated until the socket is closed.

TCP client code

We begin our TCP client by including the header file, chap03.h, which was printed at the beginning of this chapter. This header file includes the various other headers and macros we need for cross-platform networking:

/*tcp_client.c*/
#include "chap03.h"

On Windows, we also need the conio.h header. This is required for the _kbhit() function, which helps us by indicating whether terminal input is waiting. We conditionally include this header, like so:

#if defined(_WIN32)
#include <conio.h>
#endif

We can then begin the main() function and initialize Winsock: please see TCP client folder in Code-and-IAC/C

int main(int argc, char *argv[]) {
#if defined(_WIN32)
    WSADATA d;
    if (WSAStartup(MAKEWORD(2, 2), &d)) {         
        fprintf(stderr, "Failed to initialize.\n");         
        return 1;
    } 
#endif

We would like our program to take the hostname and port number of the server it should connect to as command-line arguments. This makes our program flexible. We have our program check that these command-line arguments are given. If they aren't, it displays usage information:

if (argc < 3) {
    fprintf(stderr, "usage: tcp_client hostname port\n");
    return 1;
}

argc contains the number of argument values available to us. Because the first argument is always our program's name, we check that there is a total of at least three arguments. The actual values themselves are stored in argv[].

We then use these values to configure a remote address for connection:

printf("Configuring remote address...\n");
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_socktype = SOCK_STREAM;
struct addrinfo *peer_address;
if (getaddrinfo(argv[1], argv[2], &hints, &peer_address)) {         
    fprintf(stderr, "getaddrinfo() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}

This is similar to how we called getaddrinfo() in Chapter 2, Getting to Grips with Socket APIs. However, in Chapter 2, Getting to Grips with Socket APIs, we wanted it to configure a local address, whereas this time, we want it to configure a remote address.

We set hints.ai_socktype = SOCK_STREAM to tell getaddrinfo() that we want a TCP connection. Remember that we could set SOCK_DGRAM to indicate a UDP connection.

In Chapter 2, Getting to Grips with Socket APIs, we also set the family. We don't need to set the family here, as we can let getaddrinfo() decide if IPv4 or IPv6 is the proper protocol to use.

For the call to getaddrinfo() itself, we pass in the hostname and port as the first two arguments. These are passed directly in from the command line. If they aren't suitable, then getaddrinfo() returns non-zero and we print an error message. If everything goes well, then our remote address is in the peer_address variable.

getaddrinfo() is very flexible about how it takes inputs. The hostname could be a domain name like example.com or an IP address such as 192.168.17.23 or ::1. The port can be a number, such as 80, or a protocol, such as http.

After getaddrinfo() configures the remote address, we print it out. This isn't really necessary, but it is a good debugging measure. We use getnameinfo() to convert the address back into a string, like this:

printf("Remote address is: ");
char address_buffer[100];
char service_buffer[100];
getnameinfo(peer_address->ai_addr, peer_address->ai_addrlen, address_buffer, sizeof(address_buffer), service_buffer, 
            sizeof(service_buffer), NI_NUMERICHOST);
printf("%s %s\n", address_buffer, service_buffer);

We can then create our socket:

printf("Creating socket...\n");
SOCKET socket_peer;
socket_peer = socket(peer_address->ai_family, peer_address->ai_socktype, peer_address->ai_protocol);
if (!ISVALIDSOCKET(socket_peer)) {
    fprintf(stderr, "socket() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}

This call to socket() is done in exactly the same way as it was in Chapter 2, Getting to Grips with Socket APIs. We use peer_address to set the proper socket family and protocols. This keeps our program very flexible, as the socket() call creates an IPv4 or IPv6 socket as needed.

After the socket has been created, we call connect() to establish a connection to the remote server:

printf("Connecting...\n");
if (connect(socket_peer, peer_address->ai_addr, peer_address->ai_addrlen)) {         
    fprintf(stderr, "connect() failed. (%d)\n", GETSOCKETERRNO());
    return 1;
}
freeaddrinfo(peer_address);

connect() takes three arguments—the socket, the remote address, and the remote address length. It returns 0 on success, so we print an error message if it returns non-zero. This call to connect() is extremely similar to how we called bind() in Chapter 2, Getting to Grips with Socket APIs. Where bind() associates a socket with a local address, connect() associates a socket with a remote address and initiates the TCP connection.

After we've called connect() with peer_address, we use the freeaddrinfo() function to free the memory for peer_address.

If we've made it this far, then a TCP connection has been established to the remote server. We let the user know by printing a message and instructions on how to send data:

printf("Connected.\n");
printf("To send data, enter text followed by enter.\n");

Our program should now loop while checking both the terminal and socket for new data. If new data comes from the terminal, we send it over the socket. If new data is read from the socket, we print it out to the terminal.

It is clear we cannot call recv() directly here. If we did, it would block until data comes from the socket. In the meantime, if our user enters data on the terminal, that input is ignored. Instead, we use select(). We begin our loop and set up the call to select(), like this:

while(1) {
    fd_set reads;
    FD_ZERO(&reads);
    FD_SET(socket_peer, &reads);
#if !defined(_WIN32)
    FD_SET(0, &reads);
#endif
    struct timeval timeout;
    timeout.tv_sec = 0;
    timeout.tv_usec = 100000;

    if (select(socket_peer+1, &reads, 0, 0, &timeout) < 0) {
        fprintf(stderr, "select() failed. (%d)\n", GETSOCKETERRNO());           
        return 1;
    }

First, we declare a variable, fd_set reads, to store our socket set. We then zero it with FD_ZERO() and add our only socket, socket_peer.

On non-Windows systems, we also use select() to monitor for terminal input. We add stdin to the reads set with FD_SET(0, &reads). This works because 0 is the file descriptor for stdin. Alternatively, we could have used FD_SET(fileno(stdin),
&reads) to the same effect.

The Windows select() function only works on sockets. Therefore, we cannot use select() to monitor for console input. For this reason, we set up a timeout to the select() call for 100 milliseconds (100,000 microseconds). If there is no socket activity after 100 milliseconds, select() returns, and we can check for terminal input manually.

After select() returns, we check to see whether our socket is set in reads. If it is, then we know to call recv() to read the new data. The new data is printed to the console with printf(): 

if (FD_ISSET(socket_peer, &reads)) {
    char read[4096];
    int bytes_received = recv(socket_peer, read, 4096, 0);             
    if (bytes_received < 1) {
        printf("Connection closed by peer.\n");                 
        break;
    }
    printf("Received (%d bytes): %.*s", bytes_received, bytes_received, read);
}

Remember, the data from recv() is not null terminated. For this reason, we use the %.*s printf() format specifier, which prints a string of a specified length.

recv() normally returns the number of bytes read. If it returns less than 1, then the connection has ended, and we break out of the loop to shut it down.

After checking for new TCP data, we also need to check for terminal input:

#if defined(_WIN32)         
    if(_kbhit()) {
#else
    if(FD_ISSET(0, &reads)) {
#endif
        char read[4096];
        if (!fgets(read, 4096, stdin)) break;
        printf("Sending: %s", read);
        int bytes_sent = send(socket_peer, read, strlen(read), 0);             
        printf("Sent %d bytes.\n", bytes_sent);
    }

On Windows, we use the _kbhit() function to indicate whether any console input is waiting. _kbhit() returns non-zero if an unhandled key press event is queued up. For Unix-based systems, we simply check if select() sets the stdin file descriptor, 0. If input is ready, we call fgets() to read the next line of input. This input is then sent over our connected socket with send().

Note that fgets() includes the newline character from the input. Therefore, our sent input always ends with a newline.

If the socket has closed, send() returns -1. We ignore this case here. This is because a closed socket causes select() to return immediately, and we notice the closed socket on the next call to recv(). This is a common paradigm in TCP socket programming to ignore errors on send() while detecting and handling them on recv(). It allows us to simplify our program by keeping our connection closing logic all in one place. Later in this chapter, we will discuss other concerns regarding send().

This select() based terminal monitoring works very well on Unix-based systems. It also works equally well if input is piped in. For example, you could use our TCP client program to send a text file with a command such as cat my_file.txt | tcp_client 192.168.54.122 8080.

The Windows terminal handling leaves a bit to be desired. Windows does not provide an easy way to tell whether stdin has input available without blocking, so we use _kbhit() as a poor proxy. However, if the user presses a non-printable key, such as an arrow key, it still triggers _kbhit(), even though there is no character to read. Also, after the first key press, our program will block on fgets() until the user presses the Enter key. (This doesn't happen on shells that buffer entire lines, which is common outside of Windows.) This blocking behavior is acceptable, but you should know that any received TCP data will not display until after that point. _kbhit() does not work for piped input. Doing proper piped and console input on Windows is possible, of course, but it's very complicated.

We would need to use separate functions for each (PeekNamedPipe() and PeekConsoleInput()), and the logic for handling it would be as long as this entire program! Since handling terminal input isn't the purpose of this book, we're going to accept _kbhit() function's limitations and move on.

At this point, our program is essentially done. We can end the while loop, close our socket, and clean up Winsock:

    }
    printf("Closing socket...\n");
    CLOSESOCKET(socket_peer);
#if defined(_WIN32)
    WSACleanup();
#endif
    printf("Finished.\n");
    return EXIT_SUCCESS;
}

That's the complete program. You can compile it on Linux and macOS like this:
gcc tcp_client.c -o tcp_client

Compiling on Windows with MinGW is done like this:
gcc tcp_client.c -o tcp_client.exe -lws2_32

To run the program, remember to pass in the remote hostname/address and port number, for example:
tcp_client example.com 80
Alternatively, you can use the following command:
tcp_client 127.0.0.1 8080

A fun way to test out the TCP client would be to connect to a live web server and send an HTTP request. For example, you could connect to example.com on port 80 and send the following HTTP request:
GET / HTTP/1.1
Host: example.com

You must then send a blank line to indicate the end of the request. You'll receive an HTTP response back. It might look something like this: see image on page 87

A TCP server

Microservices have become increasingly popular in recent years. The idea of microservices is that large programming problems can be split up into many small subsystems that communicate over a network. For example, if your program needs to format a string, you could add code to your program to do that, but writing code is hard. Alternatively, you could keep your program simple and instead connect to a service that provides string formatting for you. This has the added advantage that many programs can use this same service without reinventing the wheel.

Unfortunately, the microservice paradigm has largely avoided the C ecosystem; until now!

As a motivating example, we are going to build a TCP server that converts strings into uppercase. If a client connects and sends Hello, then our program will send HELLO back. This will serve as a very basic microservice. Of course, a real-world microservice might do something a bit more advanced (such as left-pad a string), but this to-uppercase service works well for our pedagogical purposes.

For our microservice to be useful, it does need to handle many simultaneous incoming connections. We again use select() to see which connections need to be serviced.

Our basic program flow looks like this: view image on page 89

Like in Chapter 2, Getting to Grips with Socket APIs, our TCP server uses getaddrinfo() to obtain the local address to listen on. It creates a socket with socket(), uses bind() to associate the local address to the socket, and uses listen() to begin listening for new connections. Up until that point, it is essentially identical to our TCP server from Chapter 2, Getting to Grips with Socket APIs.

However, our next step is not to call accept() to wait for new connections. Instead, we call select(), which alerts us if a new connection is available or if any of our established connections have new data ready. Only when we know that a new connection is waiting do we call accept(). All established connections are put into an fd_set, which is passed to every subsequent select() call. In this same way, we know which connections would block on recv(), and we only service those connections that we know will not block.

When data is received by recv(), we run it through toupper() and return it to the client using send().

This is a complicated program with several new concepts. Don't worry about understanding all the details right now. The flow is only intended to give you an overview of what to expect before we dive into the actual code.

TCP server code

Our TCP server code begins by including the needed headers, starting main(), and initializing Winsock. Refer to Chapter 2, Getting to Grips with Socket APIs, if this doesn't seem familiar:

#include "chap03.h"
#include <ctype.h>

int main()
{
#if defined(_WIN32)
    WSADATA d;
    if (WSAStartup(MAKEWORD(2, 2), &d)) {         
        fprintf(stderr, "Failed to initialize.\n");         
        return 1;
    } 
#endif
}

We then get our local address, create our socket, and bind(). This is all done exactly as explained in Chapter 2, Getting to Grips with Socket APIs:

printf("Configuring local address...\n");
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;
struct addrinfo *bind_address;
getaddrinfo(0, "8080", &hints, &bind_address);
printf("Creating socket...\n");
SOCKET socket_listen;
socket_listen = socket(bind_address->ai_family, bind_address->ai_socktype,bind_address->ai_protocol);     if (!ISVALIDSOCKET(socket_listen)) {
    fprintf(stderr, "socket() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}

Note that we are going to listen on port 8080. You can, of course, change that. We're also doing an IPv4 server here. If you want to listen for connections on IPv6, then just change AF_INET to AF_INET6.

We then bind() our socket to the local address and have it enter a listening state. Again, this is done exactly as in Chapter 2, Getting to Grips with Socket APIs: 

printf("Binding socket to local address...\n");
if (bind(socket_listen, bind_address->ai_addr, bind_address->ai_addrlen)) {         
    fprintf(stderr, "bind() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}
freeaddrinfo(bind_address);
printf("Listening...\n");
if (listen(socket_listen, 10) < 0) {
    fprintf(stderr, "listen() failed. (%d)\n", GETSOCKETERRNO());         return 1;
}

This is the point where we diverge from our earlier methods. We now define an fd_set structure that stores all of the active sockets. We also maintain a max_socket variable, which holds the largest socket descriptor. For now, we add only our listening socket to the set. Because it's the only socket, it must also be the largest, so we set
max_socket = socket_listen too:

fd_set master;
FD_ZERO(&master);
FD_SET(socket_listen, &master);
SOCKET max_socket = socket_listen;

Later in the program, we will add new connections to master as they are established. We then print a status message, enter the main loop, and set up our call to select():

printf("Waiting for connections...\n");
while(1) {
    fd_set reads;
    reads = master;
    if (select(max_socket+1, &reads, 0, 0, 0) < 0) {             
        fprintf(stderr, "select() failed. (%d)\n", GETSOCKETERRNO());             
        return 1;
    }

This works by first copying our fd_set master into reads. Recall that select() modifies the set given to it. If we didn't copy master, we would lose its data.

We pass a timeout value of 0 (NULL) to select() so that it doesn't return until a socket in the master set is ready to be read from. At the beginning of our program, master only contains socket_listen, but as our program runs, we add each new connection to master.

We now loop through each possible socket and see whether it was flagged by select() as being ready. If a socket, X, was flagged by select(), then FD_ISSET(X, &reads) is true. Socket descriptors are positive integers, so we can try every possible socket descriptor up to max_socket. The basic structure of our loop is as follows:

SOCKET i;
for(i = 1; i <= max_socket; ++i) {
    if (FD_ISSET(i, &reads)){
        //Handle socket
    } 
}

Remember, FD_ISSET() is only true for sockets that are ready to be read. In the case of socket_listen, this means that a new connection is ready to be established with accept(). For all other sockets, it means that data is ready to be read with recv(). We should first determine whether the current socket is the listening one or not. If it is, we call accept(). This code snippet and the one that follows replace the //Handle socket comment in the preceding code:

if (i == socket_listen) {
    struct sockaddr_storage client_address;                     
    socklen_t client_len = sizeof(client_address);                     
    SOCKET socket_client = accept(socket_listen, (struct sockaddr*) &client_address, &client_len);
    if (!ISVALIDSOCKET(socket_client)) {                         
        fprintf(stderr, "accept() failed. (%d)\n", GETSOCKETERRNO());                         
        return 1;
    }
    FD_SET(socket_client, &master);                     
    if (socket_client > max_socket)                         
        max_socket = socket_client;

    char address_buffer[100];
    getnameinfo((struct sockaddr*)&client_address, client_len, address_buffer, sizeof(address_buffer), 0 ,0,     NI_NUMERICHOST);
    printf("New connection from %s\n", address_buffer);

If the socket is socket_listen, then we accept() the connection much as we did in Chapter 2, Getting to Grips with Socket APIs. We use FD_SET() to add the new connection's socket to the master socket set. This allows us to monitor it with subsequent calls to select(). We also maintain max_socket. As a final step, this code prints out the client's address using getnameinfo().

If the socket i is not socket_listen, then it is instead a request for an established connection. In this case, we need to read it with recv(), convert it into uppercase using the built-in toupper() function, and send the data back:

} 
else 
{
    char read[1024];
    int bytes_received = recv(i, read, 1024, 0);                     
    if (bytes_received < 1) {
        FD_CLR(i, &master);
        CLOSESOCKET(i);
        continue;
    }
    int j;
    for (j = 0; j < bytes_received; ++j)                         
        read[j] = toupper(read[j]);                    
    send(i, read, bytes_received, 0);
}

If the client has disconnected, then recv() returns a non-positive number. In this case, we remove that socket from the master socket set, and we also call CLOSESOCKET() on it to clean up.

Our program is now almost finished. We can end the if FD_ISSET() statement, end the for loop, end the while loop, close the listening socket, and clean up Winsock:

            } //if FD_ISSET
        } //for i to max_socket
    } //while(1)
    printf("Closing listening socket...\n");     
    CLOSESOCKET(socket_listen);
#if defined(_WIN32)
    WSACleanup();
#endif
    printf("Finished.\n");     
    return 0;
}

Our program is set up to continuously listen for connections, so the code after the end of the while loop will never run. Nevertheless, I believe it is still good practice to include it in case we program in functionality later to abort the while loop.

That's the complete to-uppercase microservice TCP server program. You can compile and run it on Linux and macOS like this:

gcc tcp_serve_toupper.c -o tcp_serve_toupper
./tcp_serve_toupper

Compiling and running on Windows with MinGW is done like this:

gcc tcp_serve_toupper.c -o tcp_serve_toupper.exe -lws2_32
tcp_serve_toupper.exe

You can abort the program's execution with Ctrl + C.

Once the program is running, I would suggest opening another terminal and running the tcp_client program from earlier to connect to it:

tcp_client 127.0.0.1 8080

Anything you type in tcp_client should be sent back as uppercase. Here's what this might look like: look at page 95

As a test of the server program's functionality, try opening several additional terminals and connecting with tcp_client. Our server should be able to handle many simultaneous connections.

Also included with this chapter's code is tcp_serve_toupper_fork.c. This program only runs on Unix-based operating systems, but it performs the same functions as tcp_serve_toupper.c by using fork() instead of select(). The fork() function is commonly used by TCP servers, so I think it's helpful to be familiar with it.

Building a chat room

It is also possible, and common, to need to send data between connected clients. We can modify our tcp_serve_toupper.c program and make it a chat room pretty easily.

First, locate the following code in tcp_serve_toupper.c:

/*tcp_serve_toupper.c excerpt*/
                    int j;
                    for (j = 0; j < bytes_received; ++j)                        
                        read[j] = toupper(read[j]);                     
                    send(i, read, bytes_received, 0);

Replace the preceding code with the following:

/*tcp_serve_chat.c excerpt*/
                    SOCKET j;
                    for (j = 1; j <= max_socket; ++j) {                         
                        if (FD_ISSET(j, &master)) {                             
                            if (j == socket_listen || j == i)                                 
                                continue;
                            else
                                send(j, read, bytes_received, 0);
                        }
                    }

This works by looping through all the sockets in the master set. For each socket, j, we check that it's not the listening socket and we check that it's not the same socket that sent the data in the first place. If it's not, we call send() to echo the received data to it.

You can compile and run this program in the same way as the previous one.

On Linux and macOS, this is done as follows:

gcc tcp_serve_chat.c -o tcp_serve_chat
./tcp_serve_chat

On Windows, this is done as follows:

gcc tcp_serve_chat.c -o tcp_serve_chat.exe -lws2_32 tcp_serve_chat.exe

You should open two or more additional windows and connect to it with the following code:

tcp_client 127.0.0.1 8080

Whatever you type in one of the tcp_client terminals get sent to all of the other connected terminals.

Here is an example of what this may look like: look snapshots on page 97

In the preceding screenshot, I am running tcp_serve_chat in the upper-left terminal windows. The other three terminal windows are running tcp_client. As you can see, any text entered in one of the tcp_client windows is sent to the server, which relays it to the other two connected clients.

Blocking on send()

When we call send() with an amount of data, send() first copies this data into an outgoing buffer provided by the operating system. If we call send() when its outgoing buffer is already full, it blocks until its buffer has emptied enough to accept more of our data.

In some cases where send() would block, it instead returns without copying all of the data as requested. In this case, the return value of send() indicates how many bytes were actually copied. One example of this is if your program is blocking on send() and then receives a signal from the operating system. In these cases, it is up to the caller to try again with any remaining data.

In this chapter's TCP server code section, we ignored the possibility that send() could block or be interrupted. In a fully robust application, what we need to do is compare the return value from send() with the number of bytes that we tried to send. If the number of bytes actually sent is less than requested, we should use select() to determine when the socket is ready to accept new data, and then call send() with the remaining data. As you can imagine, this can become a bit complicated when keeping track of multiple sockets.

As the operating system usually provides a large enough outgoing buffer, we were able to avoid this possibility with our earlier server code. If we know that our server may try to send large amounts of data, we should certainly check for the return value from send().

The following code example assumes that buffer contains buffer_len bytes of data to send over a socket called peer_socket. This code blocks until we've sent all of buffer or an error (such as the peer disconnecting) occurs:

int begin = 0;
while (begin < buffer_len) {
    int sent = send(peer_socket, buffer + begin, buffer_len - begin, 0);     
    if (sent == -1) {
        //Handle error     
    }
    begin += sent; 
}

If we are managing multiple sockets and don't want to block, then we should put all sockets with pending send() into an fd_set and pass it as the third parameter to select(). When select() signals on these sockets, then we know that they are ready to send more data.
Chapter 13, Socket Programming Tips and Pitfalls, addresses concerns regarding the send() function's blocking behavior in more detail.

TCP is a stream protocol

A common mistake beginners make is assuming that any data passed into send() can be read by recv() on the other end in the same amount. In reality, sending data is similar to writing and reading from a file. If we write 10 bytes to a file, followed by another 10 bytes, then the file has 20 bytes of data. If the file is to be read later, we could read 5 bytes and 15 bytes, or we could read all 20 bytes at once, and so on. In any case, we have no way of knowing that the file was written in two 10 byte chunks.

Using send() and recv() works the same way. If you send() 20 bytes, it's not possible to tell how many recv() calls these bytes are partitioned into. It is possible that one call to recv() could return all 20 bytes, but it is also possible that a first call to recv() returns 16 bytes and that a second call to recv() is needed to get the last 4 bytes.

This can make communication difficult. In many protocols, as we will see later in this book, it is important that received data be buffered up until enough of it has accumulated to warrant processing. We avoided this issue in this chapter with our to-uppercase sever by defining a protocol that operates just as well on 1 byte as it does on 100. This isn't true for most application protocols.

For a concrete example, imagine we wanted to make our tcp_serve_toupper server terminate if it received the quit command through a TCP socket. You could call send(socket, "quit", 4, 0) on the client and you may think that a call to recv() on the server would return quit. Indeed, in your testing, it is very likely to work that way. However, this behavior is not guaranteed. A call to recv() could just as likely return qui, and a second call to recv() may be required to receive the last t. If that is the case, consider how you would interpret whether a quit command has been received. The straightforward way to do it would be to buffer up data that's received from multiple recv() calls.

We will cover techniques for dealing with recv() buffering in Section 2, An Overview of Application Layer Protocols, of this book.
In contrast to TCP, UDP is not a stream protocol. With UDP, a packet is received with exactly the same contents as it was sent with. This can sometimes make handling UDP somewhat easier, as we will see in Chapter 4, Establishing UDP Connections.

4. Establishing UDP Connections

The socket API for UDP sockets is only very slightly different than what we've already learned for TCP. In fact, they are similar enough that we can take the TCP client from the last chapter and turn it into a fully functional UDP client by changing only one line of code:

1. Take tcp_client.c from Chapter 3, An In-Depth Overview of TCP Connections, and find the following line of code:

hints.ai_socktype = SOCK_STREAM;

2. Change the preceding code to the following:

hints.ai_socktype = SOCK_DGRAM;

You can recompile the program using the same commands as before, and you'll get a fully functional UDP client.
Unfortunately, changing the TCP servers of the previous chapters to UDP won't be as easy. TCP and UDP server code are different enough that a slightly different approach is needed.
Also, don't assume that because we had to change only one line of the code that the client behaves exactly the same way – this won't happen. The two programs are using a different protocol, after all.

Remember from Chapter 2, Getting to Grips with Socket APIs that UDP does not try to be a reliable protocol. Lost packets are not automatically re-transmitted, and packets may be received in a different order than they were sent. It is even possible for one packet to erroneously arrive twice! TCP attempts to solve all these problems, but UDP leaves you to your own devices.

Despite UDP's (lack of) reliability, it is still appropriate for many applications. Let's look at the methods that are used by UDP clients and servers.

UDP client methods

Sending data with TCP requires calling connect() to set the remote address and establish the TCP connection. Thus, we use send() with TCP sockets, as shown in the following code:

connect(tcp_socket, peer_address, peer_address_length);
send(tcp_socket, data, data_length, 0);

UDP is a connectionless protocol. Therefore, no connection is established before sending data. A UDP connection is never established. With UDP, data is simply sent and received. We can call connect() and then send(), as we mentioned previously, but the socket API provides an easier way for UDP sockets in the form of the sendto() function. It works like this:

sendto(udp_socket, data, data_length, 0, peer_address, peer_address_length);

connect() on a UDP socket works a bit differently. All connect() does with a UDP socket is associate a remote address. Thus, while connect() on a TCP socket involves a handshake for sending packets over the network, connect() on a UDP socket only stores an address locally.

So, a UDP client can be structured in two different ways, depending on whether you use connect(), send(), and recv(), or instead use sendto() and recvfrom().

The following diagram compares the program flow of a TCP Client to a UDP Client using either method: see Chapter 4: Establishing UDP Connections

Note that, while using connect(), the UDP Client only receives data from the peer having the IP address and the port that is given to connect(). However, when not using connect(), the recvfrom() function returns data from any peer that addresses us! Of course, that peer would need to know our address and port. Unless we call bind(), our local address and port is assigned automatically by the operating system.

UDP server methods

Programming a UDP server is a bit different than TCP. TCP requires managing a socket for each peer connection. With UDP, our program only needs one socket. That one socket can communicate with any number of peers.

While the TCP program flow required us to use listen() and accept() to wait for and establish new connections, these functions are not used with UDP. Our UDP server simply binds to the local address, and then it can immediately start sending and receiving data.

The program flow of a TCP Server compared to a UDP Server is as follows: see diagram

With either a TCP or UDP server, we use select() when we need to check/wait for incoming data. The difference is that a TCP Server using select() is likely monitoring many separate sockets, while a UDP Server often only needs to monitor one socket. If your program uses both TCP and UDP sockets, you can monitor them all with only one call to select().

A first UDP client/server

To keep things simple, we will create a UDP client program that simply sends the Hello World string to 127.0.0.1 on port 8080. Our UDP server listens on 8080. It prints any data it receives, along with the sender's address and port number.

A simple UDP server

We will start with the server, since we already have a usable UDP client, that is, udp_client.c.

Like all of our networked programs, we will begin by including the necessary headers, starting with the main() function, and initializing Winsock as follows:

/*udp_recvfrom.c*/
#include "chap04.h"

int main() {
#if defined(_WIN32)

    WSADATA d;
    if (WSAStartup(MAKEWORD(2, 2), &d)) {         
        fprintf(stderr, "Failed to initialize.\n");         
        return 1;
    }
#endif

Then, we must configure the local address that our server listens on. We use getaddrinfo() for this, as follows:

printf("Configuring local address...\n");
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_DGRAM;
hints.ai_flags = AI_PASSIVE;
struct addrinfo *bind_address;
getaddrinfo(0, "8080", &hints, &bind_address);

This differs only slightly from how we've done it before. Notably, we set hints.ai_socktype = SOCK_DGRAM. Recall that SOCK_STREAM was used there for TCP connections. We are still setting hints.ai_family = AF_INET here. This makes our server listen for IPv4 connections. We could change that to AF_INET6 to make our server listen for IPv6 connections instead.

After we have our local address information, we can create the socket, as follows:

printf("Creating socket...\n");
SOCKET socket_listen;
socket_listen = socket(bind_address->ai_family, bind_address->ai_socktype, bind_address->ai_protocol);    
if(!ISVALIDSOCKET(socket_listen)) {
    fprintf(stderr, "socket() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}

This code is exactly the same as in the TCP case. The call to socket() uses our address information from getaddrinfo() to create the proper type of socket.

We must then bind the new socket to the local address that we got from getaddrinfo(). This is as follows:

printf("Binding socket to local address...\n");     
if (bind(socket_listen, bind_address->ai_addr, bind_address->ai_addrlen)) {         
    fprintf(stderr, "bind() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}
freeaddrinfo(bind_address);

Again, that code is exactly the same as in the TCP case.

Here is where the UDP server diverges from the TCP server. Once the local address is bound, we can simply start to receive data. There is no need to call listen() or accept(). We listen for incoming data using recvfrom(), as shown here:

struct sockaddr_storage client_address;
socklen_t client_len = sizeof(client_address);
char read[1024];
int bytes_received = recvfrom(socket_listen, read, 1024, 0, (struct sockaddr*) &client_address, &client_len);

In the previous code, we created a struct sockaddr_storage to store the client's address. We also defined socklen_t client_len to hold the address size. This keeps our code robust in the case that we change it from IPv4 to IPv6. Finally, we created a buffer, char read[1024], to store incoming data.

recvfrom() is used in a similar manner to recv(), except that it returns the sender's address, as well as the received data. You can think of recvfrom() as a combination of the TCP server accept() and recv().

Once we've received data, we can print it out. Keep in mind that the data may not be null terminated. It can be safely printed with the %.*s printf() format specifier, as shown in the following code:

printf("Received (%d bytes): %.*s\n", bytes_received, bytes_received, read);

It may also be useful to print the sender's address and port number. We can use the getnameinfo() function to convert this data into a printable string, as shown in the following code:

printf("Remote address is: ");
char address_buffer[100];
char service_buffer[100];
getnameinfo(((struct sockaddr*)&client_address), client_len, address_buffer, sizeof(address_buffer),
            service_buffer, sizeof(service_buffer), NI_NUMERICHOST | NI_NUMERICSERV);
printf("%s %s\n", address_buffer, service_buffer);

The last argument to getnameinfo() (NI_NUMERICHOST | NI_NUMERICSERV) tells getnameinfo() that we want both the client address and port number to be in numeric form. Without this, it would attempt to return a hostname or protocol name if the port number matches a known protocol. If you do want a protocol name, pass in the NI_DGRAM flag to tell getnameinfo() that you're working on a UDP port. This is important for the few protocols that have different ports for TCP and UDP.

It's also worth noting that the client will rarely set its local port number explicitly. So, the port number returned here by getnameinfo() is likely to be a high number that's chosen randomly by the client's operating system. Even if the client did set its local port number, the port number we can see here might have been changed by network address translation (NAT).

In any case, if our server were to send data back, it would need to send it to the address and port stored in client_address. This would be done by passing client_address to sendto().

Once the data has been received, we'll end our simple UDP server by closing the connection, cleaning up Winsock, and ending the program:

CLOSESOCKET(socket_listen);

#if defined(_WIN32)
    WSACleanup();
#endif

printf("Finished.\n");

return EXIT_SUCCESS;
}

A simple UDP client

Although we've already shown a fairly full-featured UDP client, udp_client.c, it is worthwhile building a very simple UDP client. This client shows only the minimal required steps to get a working UDP client, and it uses sendto() instead of send().

Let's begin the same way we begin each program, by including the necessary headers, starting main(), and initializing Winsock, as follows:

#include "chap04.h"

int main() {
#if defined(_WIN32)
    WSADATA d;
    if (WSAStartup(MAKEWORD(2, 2), &d)) {         
        fprintf(stderr, "Failed to initialize.\n");         
        return 1;
    } 
#endif

We then configure the remote address using getaddrinfo(). In this minimal example, we use 127.0.0.1 as the remote address and 8080 as the remote port. This means that it connects to the UDP server only if it's running on the same computer.

printf("Configuring remote address...\n");
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_socktype = SOCK_DGRAM;
struct addrinfo *peer_address;
if (getaddrinfo("127.0.0.1", "8080", &hints, &peer_address)) {         
    fprintf(stderr, "getaddrinfo() failed. (%d)\n", GETSOCKETERRNO());         
    return EXIT_FAILURE;
}

Notice that we hardcoded 127.0.0.1 and 8080 into the call to getaddrinfo(). Also, notice that we've set hints.ai_socktype = SOCK_DGRAM. This tells getaddrinfo() that we are connecting over UDP. Notice that we did not set AF_INET or AF_INET6. This allows getaddrinfo() to return the appropriate address for IPv4 or IPv6. In this case, it is IPv4 because the address, 127.0.0.1, is an IPv4 address.

We can print the configured address using getnameinfo(). The call to getnameinfo() is the same as in the previous UDP server, udp_recvfrom.c. It works as follows:

printf("Remote address is: ");
char address_buffer[100];
char service_buffer[100];
getnameinfo(peer_address->ai_addr, peer_address->ai_addrlen, address_buffer, sizeof(address_buffer),    
            service_buffer, sizeof(service_buffer), NI_NUMERICHOST  | NI_NUMERICSERV);
printf("%s %s\n", address_buffer, service_buffer);

Now that we've stored the remote address, we are ready to create our socket with a call to socket(). We pass in fields from peer_address to create the appropriate socket type. The code for this is as follows:

printf("Creating socket...\n");
SOCKET socket_peer;
socket_peer = socket(peer_address->ai_family, peer_address->ai_socktype, peer_address->ai_protocol);     
if (!ISVALIDSOCKET(socket_peer)) {
    fprintf(stderr, "socket() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}

Once the socket has been created, we can go straight to sending data with sendto(). There is no need to call connect(). Here is the code to send Hello World to our UDP server:

const char *message = "Hello World";
printf("Sending: %s\n", message);
int bytes_sent = sendto(socket_peer, message, strlen(message),0,peer_address->ai_addr,peer_address->ai_addrlen);
printf("Sent %d bytes.\n", bytes_sent);

Notice that sendto() is much like send(), except that we need to pass in an address as the last parameter.

It is also worth noting that we do not get an error back if sending fails. send() simply tries to send a message, but if it gets lost or is misdelivered along the way, there is nothing we can do about it. If the message is important, it is up to the application protocol to implement the corrective action.

After we've sent our data, we could reuse the same socket to send data to another address (as long as it's the same type of address, which is IPv4 in this case). We could also try to receive a reply from the UDP server by calling recvfrom(). Note that if we did call recvfrom() here, we could get data from anybody that sends to us – not necessarily the server we just transmitted to.

When we sent our data, our socket was assigned with a temporary local port number by the operating system. This local port number is called the ephemeral port number. From then on, our socket is essentially listening for a reply on this local port. If the local port is important, you can use bind() to associate a specific port before calling send().

If multiple applications on the same system are connecting to a remote server at the same port, the operating system uses the local ephemeral port number to keep replies separate. Without this, it wouldn't be possible to know which application should receive which reply.

We'll end our example program by freeing the memory for peer_address, closing the socket, cleaning up Winsock, and finishing main(), as follows:

freeaddrinfo(peer_address);
    CLOSESOCKET(socket_peer);
#if defined(_WIN32)
    WSACleanup();
#endif
    printf("Finished.\n");
    return EXIT_SUCCESS;

}

To test it out, first, start udp_recvfrom in a separate terminal. With udp_recvfrom already running, you can start udp_sendto. It should look as follows: see image

If no server is running on port 8080, udp_sendto still produces the same output. udp_sendto doesn't know that the packet was not delivered.

A UDP server

It will be useful to look at a UDP server that's been designed to service many connections. Fortunately for us, the UDP socket API makes this very easy.

Our server begins by setting up the socket and binding to our local address. It then waits to receive data. Once it has received a data string, it converts the string into all uppercase and sends it back.

The program flow looks as follows: see image

If you compare the flow of this program to the TCP server from the last chapter (Chapter 3, An In-Depth Overview of TCP Connections), you will find that it's much simpler. With TCP, we had to use listen() and accept(). With UDP, we skip those calls and go straight into receiving data with recvfrom(). With our TCP server, we had to monitor a listening socket for new connections while simultaneously monitoring an additional socket for each connected client. Our UDP server only uses one socket, so there is much less to keep track of.

Our UDP server program begins by including the necessary headers, starting the main() function, and initializing Winsock, as follows:

#include "chap04.h"

#include <ctype.h>

int main() {
#if defined(_WIN32)
    WSADATA d;
    if (WSAStartup(MAKEWORD(2, 2), &d)) {
        fprintf(stderr, "Failed to initialize.\n");
        return 1;
    }
#endif

We then find our local address that we should listen on, create the socket, and bind to it. This is all exactly the same as in our earlier server, udp_recvfrom.c. The only difference between this code and the TCP servers in Chapter 3, An In-Depth Overview of TCP Connections, is that we use SOCK_DGRAM instead of SOCK_STREAM. Recall that SOCK_DGRAM specifies that we want a UDP socket.

printf("Configuring local address...\n");     
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_DGRAM;
hints.ai_flags = AI_PASSIVE;
struct addrinfo *bind_address;
getaddrinfo(0, "8080", &hints, &bind_address);

printf("Creating socket...\n");
SOCKET socket_listen;
socket_listen = socket(bind_address->ai_family,bind_address->ai_socktype, bind_address->ai_protocol);     

if (!ISVALIDSOCKET(socket_listen)) {
    fprintf(stderr, "socket() failed. (%d)\n", GETSOCKETERRNO());         
    return EXIT_SUCCESS;
}

Binding the new socket to the local address is done as follows:

printf("Creating socket...\n");
SOCKET socket_listen;
socket_listen = socket(bind_address->ai_family,bind_address->ai_socktype, bind_address->ai_protocol);     

if (!ISVALIDSOCKET(socket_listen)) {
    fprintf(stderr, "socket() failed. (%d)\n", GETSOCKETERRNO());         
    return EXIT_SUCCESS;
}

Because our server uses select(), we need to create a new fd_set to store our listening socket. We zero the set using FD_ZERO(), and then add our socket to this set using FD_SET(). We also maintain the maximum socket in the set using max_socket:

Note that we don't really have to use select() for this program, and omitting it would make the program simpler (see udp_server_toupper_simple.c). However, we are going to use select() because it makes our code more flexible. We could easily add in an additional socket (if we needed to listen on multiple ports, for example), and we could add in a select() timeout if our program needs to perform other functions. Of course, our program doesn't do those things, so we don't need select(), but I think that most programs do, so we will show it that way.

Now, we are ready for the main loop. It copies the socket set into a new variable, reads, and then uses select() to wait until our socket is ready to read from. Recall that we could pass in a timeout value as the last parameter to select() if we want to set a maximum waiting time for the next read. 

Once select() returns, we use FD_ISSET() to tell if our particular socket, socket_listen, is ready to be read from. If we had additional sockets, we would need to use FD_ISSET() for each socket.

If FD_ISSET() returns true, we read from the socket using recvfrom(). recvfrom() gives us the sender's address, so we must first allocate a variable to hold the address, that is, client_address. Once we've read a string from the socket using recvfrom(), we convert the string into uppercase using the C toupper() function. We then send the modified text back to the sender using sendto(). Note that the last two parameters to sendto() are the client's addresses that we got from recvfrom().

while(true) 
    {
        fd_set reads;
        reads = master;
        if (select(max_socket+1, &reads, 0, 0, 0) < 0) {             
            fprintf(stderr, "select() failed. (%d)\n", GETSOCKETERRNO());             
            return EXIT_FAILURE;
        }
        if (FD_ISSET(socket_listen, &reads)) {
            struct sockaddr_storage client_address;
            socklen_t client_len = sizeof(client_address);
            char read[1024];
            int bytes_received = recvfrom(socket_listen, read, 1024, 0,(struct sockaddr *)&client_address, &client_len);             
            
            if (bytes_received < 1) {
                fprintf(stderr, "connection closed. (%d)\n", GETSOCKETERRNO());                 
                return EXIT_FAILURE;
            }
            int j;
            for (j = 0; j < bytes_received; ++j)                 
                read[j] = toupper(read[j]);

            sendto(socket_listen, read, bytes_received, 0,(struct sockaddr*)&client_address, client_len);
        }
    }

We can then close the socket, clean up Winsock, and terminate the program. Note that this code never runs, because the main loop never terminates. We include this code anyway as good practice; in case the program is adapted in the future to have an exit function.

printf("Closing listening socket...\n");
    CLOSESOCKET(socket_listen);
#if defined(_WIN32)
    WSACleanup();
#endif
    printf("Finished.\n");
    return EXIT_SUCCESS;
}

chapter 5 Hostname Resolution and DNS

Hostname resolution is a vital part of network programming. It allows us to use simple names, such as www.example.com, instead of tedious addresses such as ::ffff:192.168.212.115. The mechanism that allows us to resolve hostnames into IP addresses and IP addresses into hostnames is the Domain Name System (DNS).

The DNS is used to assign names to computers and systems connected to the internet. Similar to how a phone book can be used to link a phone number to a name, the DNS allows us to link a hostname to an IP address.

When your program needs to connect to a remote computer, such as www.example.com, it first needs to find the IP address for www.example.com. In this book so far, we have been using the built-in getaddrinfo() function for this purpose. When you call getaddrinfo(), your operating system goes through a number of steps to resolve the domain name.

First, your operating system checks whether it already knows the IP address for www.example.com. If you have used that hostname recently, the OS is allowed to remember it in a local cache for a time. This time is referred to as time-to-live (TTL) and is set by the DNS server responsible for the hostname.

If the hostname is not found in the local cache, then your operating system will need to query a DNS server. This DNS server is usually provided by your Internet Service Provider (ISP), but there are also many publicly-available DNS servers. When the DNS server receives a query, it also checks its local cache. This is useful because numerous systems may be relying on one DNS server. If a DNS server receives 1,000 requests for gmail.com in one minute, it only needs to resolve the hostname the first time. For the other 999 requests, it can simply return the memorized answer from its local cache.

If the DNS server doesn't have the requested DNS record in its cache, then it needs to query other DNS servers until it connects directly to the DNS server responsible for the target system. Here's an example query resolution broken down step-wise:

Client A's DNS server is trying to resolve www.example.com as follows:

1.  It first connects to a root DNS server and asks for www.example.com.
2.  The root DNS server directs it to ask the .com server.
3.  Our client's DNS server then connects to the server responsible for .com and asks for www.example.com.
4.  The .com DNS server gives our server the address of another server – the example.com DNS server.
5.  Our DNS server finally connects to that server and asks about the record for 5. www.example.com.
6.  The example.com server then shares the address of www.example.com. 
7.  Our client's DNS server relays it back to our client.

The following diagram illustrates this visually: see diagram

In this example, you can see that resolving www.example.com involved sending eight messages. It's possible that the lookup could have taken even longer. This is why it's imperative for DNS servers to implement caching. Let's assume that Client B tries the same query shortly after Client A; it's likely that the DNS server would have that value cached: see diagram

Of course, if a program on Client A wants to resolve www.example.com again, it's likely that it won't have to contact the DNS server at all – the operating system running on Client A should have cached the result.

On Windows, you can show your local DNS cache with the following command: ipconfig /displaydns

On Linux or macOS, the command to show your local DNS varies depending on your exact system setup.

One downside of setting a large TTL value for a domain record is that you have to wait at least that long to be sure that all clients are using the new record and not just retrieving the old cached record.

In addition to DNS records that link a hostname to an IP address, there are other DNS record types for various purposes. We'll review some of these in the next section.

DNS record types

The DNS has five main types of records—A, AAAA, MX, TXT, CNAME, and * (ALL/ANY).

As we have learned, the DNS's primary purpose is to translate hostnames into IP addresses. This is done with two record types – type A and type AAAA. These records work in the same way, but A records return an IPv4 address, while AAAA records return an IPv6 address.

The MX record type is used to return mail server information. For example, if you wanted to send an email to larry@example.com, then the MX record(s) for example.com would indicate which mail server(s) receives emails for that domain.

TXT records can be used to store arbitrary information for a hostname. In practice, these are sometimes set to prove ownership of a domain name or to publish email sending guidelines. The Sender Policy Framework (SPF) standard uses TXT records to declare which systems are allowed to send mail for a given domain name. You can read more about SPF at http://www.openspf.org/.

CNAME records can be used to provide an alias for a given name. For example, many websites are accessible at both their root domain name, for example, example.com, and at the www subdomain. If example.com and www.example.com should point to the same address, then an A and an AAAA record can be added for example.com, while a CNAME record can be added for www.example.com pointing to example.com. Note that DNS clients don't query for CNAME records directly; instead, a client would ask for the A or AAAA record for www.example.com and the DNS server would reply with the CNAME record pointing to example.com. The DNS client would then continue the query using example.com.

When doing a DNS query, there is also a pseudo-record type called * or ALL or ANY. If this record is requested from a DNS server, then the DNS server returns all known record types for the current query. Note that a DNS server is allowed to respond with only the records in its cache, and this query is not guaranteed (or even likely) to actually get all of the records for the requested domain.

When sending a DNS query, each record type has an associated type ID. The IDs for the records discussed so far are as follows: see id-records.png

It should be noted that one hostname may be associated with multiple records of the same type. For example, example.com could have several A records, each with a different IPv4 address. This is useful if multiple servers can provide the same service.

DNS security

While most web traffic and email are encrypted today, DNS is still widely used in an unsecured manner. Protocols do exist to provide security for DNS, but they are not widely adopted yet. This will hopefully change in the near future.

Domain Name System Security Extensions (DNSSEC) are DNS extensions that provide data authentication. This authentication allows a DNS client to know that a given DNS reply is authentic, but it does not protect against eavesdropping.

DNS over HTTPS (DoH) is a protocol that provides name resolution over HTTPS. HTTPS provides strong security guarantees, including resistance to interception.

What are the implications of using insecure DNS? First, if DNS is not authenticated, then it could allow an attacker to lie about a domain name's IP address. This could trick a victim into connecting to a server that they think is example.com, but, in reality, is a malicious server controlled by the attacker at a different IP address. If the user is connecting via a secure protocol, such as HTTPS, then this attack will fail. HTTPS provides additional authentication to prove server identity. However, if the user connects with an insecure protocol, such as HTTP, then the DNS attack could successfully trick the victim into connecting to the wrong server.

If DNS is authenticated, then these hijacking attacks are prevented. However, without encryption, DNS queries are still susceptible to eavesdropping. This could potentially give an eavesdropper insight into which websites you're visiting and other servers that you are connecting to (for example, which email server you use). This doesn't let an attacker know what you are doing on each website. For example, if you do a DNS query for
example.com, an attacker would know that you planned to visit example.com, but the attacker would not be able to determine which resources you requested from example.com – assuming that you use a secure protocol (for example, HTTPS) to retrieve those resources. An attacker with the ability to eavesdrop would be able to see that you established a connection to the IP address of example.com in any case, so them knowing that you performed a DNS lookup beforehand is not much extra information.

With some security discussion out of the way, let's look at how to do actual DNS lookups. Winsock and Berkeley sockets provide a simple function to do address lookup, called getaddrinfo(), which we've used in the previous chapters of this book.

Name/address translation functions

It is common for networked programs to need to translate text-based representatives of an address or hostname into an address structure required by the socket programming API. The common function we've been using is getaddrinfo(). It is a useful function because it is highly portable (available on Windows, Linux, and macOS), and it works for both IPv4 and IPv6 addresses.

It is also common to need to convert a binary address back into a text format. We use getnameinfo() for this.

Using getaddrinfo()

Although we've been using getaddrinfo() in previous chapters, we'll discuss it in more detail here.

The declaration for getaddrinfo() is shown in the following code:

int getaddrinfo(const char *node,
                const char *service,
                const struct addrinfo *hints,
                struct addrinfo **res);

The preceding code snippet is explained as follows:

node specifies a hostname or address as a string. Valid examples could be example.com, 192.168.1.1, or ::1.

service specifies a service or port number as a string. Valid examples could be http or 80. Alternately, the null pointer can be passed in for service, in which case, the resulting address is set to port 0.

hints is a pointer to a struct addrinfo, which specifies options for selecting the address. The addrinfo structure has the following fields:

struct addrinfo {
    int              ai_flags;
    int              ai_family;
    int              ai_socktype;
    int              ai_protocol;
    socklen_t        ai_addrlen;
    struct sockaddr *ai_addr;
    char            *ai_canonname;
    struct addrinfo *ai_next;
};

You should not assume that the fields are stored in the order listed in the previous code, or that additional fields aren't present. There is some variation between operating systems.

The call to getaddrinfo() looks at only four fields in *hints. The rest of the structure should be zeroed-out. The relevant fields are ai_family, ai_socktype, ai_protocol, and ai_flags:

ai_family specifies the desired address family. It can be AF_INET for IPv4, AF_INET6 for IPv6, or AF_UNSPEC for any address family. AF_UNSPEC is defined as 0.

ai_socktype could be SOCK_STREAM for TCP, or SOCK_DGRAM for UDP. Setting ai_socktype to 0 indicates that the address could be used for either.

ai_protocol should be left to 0. Strictly speaking, TCP isn't the only streaming protocol supported by the socket interface, and UDP isn't the only datagram protocol supported. ai_protocol is used to disambiguate, but it's not needed for our purposes.

ai_flags specifies additional options about how getaddrinfo() should work. Multiple flags can be used by bitwise OR-ing them together. In C, the bitwise OR operator uses the pipe symbol, |. So, bitwise OR-ing two flags together would use the (flag_one | flag_two) code.

Common flags you may use for the ai_flags field are:

AI_NUMERICHOST can be used to prevent name lookups. In this case, getaddrinfo() would expect node to be an address such as 127.0.0.1 and not a hostname such as example.com. AI_NUMERICHOST can be useful because it prevents getaddrinfo() from doing a DNS record lookup, which can be slow.

AI_NUMERICSERV can be used to only accept port numbers for the service argument. If used, this flag causes getaddrinof() to reject service names.

AI_ALL can be used to request both an IPv4 and IPv6 address. The declaration for AI_ALL seems to be missing on some Windows setups. It can be defined as 0x0100 on those platforms.

AI_ADDRCONFIG forces getaddrinfo() to only return addresses that match the family type of a configured interface on the local machine. For example, if your machine is IPv4 only, then using AI_ADDRCONFIG | AI_ALL prevents IPv6 addresses from being returned. It is usually a good idea to use this flag if you plan to connect a socket to the address returned by getaddrinfo().

AI_PASSIVE can be used with node = 0 to request the wildcard address. This is the local address that accepts connections on any of the host's network addresses. It is used on servers with bind(). If node is not 0, then AI_PASSIVE has no effect. See Chapter 3, An In-Depth Overview of TCP Connections for example usage.

All other fields in hints should be set to 0. You can also pass in 0 for the hints argument, but different operating systems implement different defaults in that case.

The final parameter to getaddrinfo(), res, is a pointer to a pointer to struct addrinfo and returns the address(es) found by getaddrinfo().

If the call to getaddrinfo() succeeds, then its return value is 0. In this case, you should call freeaddrinfo() on *res when you've finished using the address. Here is an example of using getaddrinfo() to find the address(es) for example.com:

struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_flags = AI_ALL;
struct addrinfo *peer_address;
if (getaddrinfo("example.com", 0, &hints, &peer_address)) {     
    fprintf(stderr, "getaddrinfo() failed. (%d)\n", GETSOCKETERRNO());     
    return 1;
}

Note that we first zero out hints using a call to memset(). We then set the AI_ALL flag, which specifies that we want both IPv4 and IPv6 addresses returned. This even returns addresses that we don't have a network adapter for. If you only want addresses that your machine can practically connect to, then use AI_ALL | AI_ADDRCONFIG for the ai_flags field. We can leave the other fields of hints as their defaults.

We then declare a pointer to hold the return address list: struct addrinfo *peer_address.

If the call to getaddrinfo() succeeds, then peer_address holds the first address result. The next result, if any, is in peer_address->ai_next.

We can loop through all the returned addresses with the following code:

struct addrinfo *address = peer_address;
do {
    /* Work with address... */
} while ((address = address->ai_next));

When we've finished using peer_address, we should free it with the following code: freeaddrinfo(peer_address);

Now that we can convert a text address or name into an addrinfo structure, it is useful to see how to convert the addrinfo structure back into a text format. Let's look at that now.

Using getnameinfo()

getnameinfo() can be used to convert an addrinfo structure back into a text format. It works with both IPv4 and IPv6. It also, optionally, converts a port number into a text format number or service name.

The declaration for getnameinfo() can be seen in the following code:

int getnameinfo(const struct sockaddr *addr, 
                socklen_t addrlen, 
                char *host, 
                socklen_t hostlen,
                char *serv, 
                socklen_t servlen, 
                int flags);

The first two parameters are passed in from the ai_addr and ai_addrlen fields of struct addrinfo.

The next two parameters, host and hostlen, specify a character buffer and buffer length to store the hostname or IP address text.

The following two parameters, serv and servlen, specify the buffer and length to store the service name.

If you don't need both the hostname and the service, you can optionally pass in only one of either host or serv.

Flags can be a bitwise OR combination of the following:

NI_NAMEREQD requires getnameinfo() to return a hostname and not an address. By default, getnameinfo() tries to return a hostname but returns an address if it can't. NI_NAMEREQD will cause an error to be returned if the hostname cannot be determined.

NI_DGRAM specifies that the service is UDP-based rather than TCP-based. This is only important for ports that have different standard services for UDP versus TCP. This flag is ignored if NI_NUMERICSERV is set.

NI_NUMERICHOST requests that getnameinfo() returns the IP address and not a hostname.

NI_NUMERICSERV requests that getnameinfo() returns the port number and not a service name.

For example, we can use getnameinfo() as follows:

char host[100];
char serv[100];
getnameinfo(address->ai_addr, address->ai_addrlen,
            host, 
            sizeof(host),
            serv, 
            sizeof(serv),
            0);
printf("%s %s\n", host, serv);

In the preceding code, getnameinfo() attempts to perform a reverse DNS lookup. This works like the DNS queries we've done in this chapter so far, but backward. A DNS query asks which IP address does this hostname point to? A reverse DNS query asks instead, which hostname does this IP address point to? Keep in mind that this is not a one-to-one relationship. Many hostnames can point to one IP address, but an IP address can store a DNS record for only one hostname. In fact, reverse DNS records are not even set for many IP addresses.

If address is a struct addrinfo with the address for example.com port 80 (http), then the preceding code might print as follows:

example.com http

If the code prints something different for you, it's probably working as intended. It is dependent on which address is in address and how the reverse DNS is set up for that IP address. Try it with a different address.

If, instead of the hostname, we would like the IP address, we can modify our code to the following:

char host[100];
char serv[100];
getnameinfo(address->ai_addr, 
            address->ai_addrlen,         
            host, 
            sizeof(host),
            serv, 
            sizeof(serv),
            NI_NUMERICHOST | NI_NUMERICSERV);

printf("%s %s\n", host, serv);

In the case of the previous code, it might print the following:

93.184.216.34 80

Using NI_NUMERICHOST generally runs much faster too, as it doesn't require getnameinfo() to send off any reverse DNS queries.

Alternative functions

Two widely-available functions that replicate getaddrinfo() are gethostbyname() and getservbyname(). The gethostbyname() function is obsolete and has been removed from the newer POSIX standards. Furthermore, I recommend against using these functions in new code, because they introduce an IPv4 dependency. It's very possible to use getaddrinfo() in such a way that your program does not need to be aware of IPv4 versus IPv6, but still supports both.

IP lookup example program

To demonstrate the getaddrinfo() and getnameinfo() functions, we will implement a short program. This program takes a name or IP address for its only argument. It then uses getaddrinfo() to resolve that name or that IP address into an address structure, and the program prints that IP address using getnameinfo() for the text conversion. If multiple addresses are associated with a name, it prints each of them. It also indicates any errors.

To begin with, we need to include our required header for this chapter. We also define AI_ALL for systems that are missing it. The code for this is as follows:

#include "chap05.h"

#ifndef AI_ALL
#define AI_ALL 0x0100
#endif

We can then begin the main() function and check that the user passed in a hostname to lookup. If the user doesn't pass in a hostname, we print a helpful reminder. The code for this is as follows:

int main(int argc, char *argv[]) {
    if (argc < 2) 
    {
        printf("Usage:\n\tlookup hostname\n");
        printf("Example:\n\tlookup example.com\n");         
        exit(0);
    }

We need the following code to initialize Winsock on Windows platforms:

#if defined(_WIN32)
    WSADATA d;
    if (WSAStartup(MAKEWORD(2, 2), &d)) {         
        fprintf(stderr, "Failed to initialize.\n");         
        return EXIT_FAILURE;
    } 
#endif

We can then call getaddrinfo() to convert the hostname or address into a struct addrinfo. The code for that is as follows:

printf("Resolving hostname '%s'\n", argv[1]);
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_flags = AI_ALL;
struct addrinfo *peer_address;
if (getaddrinfo(argv[1], 0, &hints, &peer_address)) {         
    fprintf(stderr, "getaddrinfo() failed. (%d)\n", GETSOCKETERRNO());         
    return EXIT_FAILURE;
}

The previous code first prints the hostname or address that is passed in as the first command-line argument. This argument is stored in argv[1]. We then set hints.ai_flags = AI_ALL to specify that we want all available addresses of any type, including both IPv4 and IPv6 addresses.

getaddrinfo() is then called with argv[1]. We pass 0 in for the service argument because we don't care about the port number. We are only trying to resolve an address. If argv[1] contains a name, such as example.com, then our operating system performs a DNS query (assuming the hostname isn't already in the local cache). If argv[1] contains an address such as 192.168.1.1, then getaddrinfo() simply fills in the resulting struct addrinfo as needed.

If the user passed in an invalid address or a hostname for which no record could be found, then getaddrinfo() returns a non-zero value. In that case, our previous code prints out the error.

Now that peer_address holds the desired address(es), we can use getnameinfo() to convert them to text. The following code does that:

printf("Remote address is:\n");
struct addrinfo *address = peer_address;
do {
    char address_buffer[100];
    getnameinfo(address->ai_addr, address->ai_addrlen, address_buffer, sizeof(address_buffer), 0, 0,     
                NI_NUMERICHOST);
    printf("\t%s\n", address_buffer);     
} while ((address = address->ai_next));

If getaddrinfo() returned multiple addresses, then the next address is pointed to by address->ai_next. We assign address->ai_next to address and loop if it is non-zero. This is a simple example of walking through a linked list.

After we've printed our address, we should use freeaddrinfo() to free the memory allocated by getaddrinfo(). We should also call the Winsock cleanup function on Windows. We can do both with the following code:

    freeaddrinfo(peer_address);
#if defined(_WIN32)
    WSACleanup();
#endif
    return EXIT_SUCCESS;
}

That concludes our lookup program.

Although getaddrinfo() makes performing DNS lookups easy, it is useful to know what happens behind the scenes. We will now look at the DNS protocol in more detail.

The DNS protocol

When a client wants to resolve a hostname into an IP address, it sends a DNS query to a DNS server. This is typically done over UDP using port 53. The DNS server then performs the lookup, if possible, and returns an answer. The following diagram illustrates this transaction: see diagram

If the query (or, more commonly, the answer) is too large to fit into one UDP packet, then the query can be performed over TCP instead of UDP. In this case, the size of the query is sent over TCP as a 16-bit value, and then the query itself is sent. This is called TCP fallback or DNS transport over TCP. However, UDP works for most cases, and UDP is how DNS is used the vast majority of the time.

It's also important to note that the client must know the IP address of at least one DNS server. If the client doesn't know of any DNS servers, then it has a sort of chicken-and-egg problem. DNS servers are usually provided by your ISP.

The actual UDP data format is simple and follows the same basic format for both the query and the answer.

DNS message format

The following illustration describes the DNS message format: see image

Every DNS message follows that format, although a query would leave the Answer, Authority, and Additional sections blank. A DNS response commonly doesn't use Authority or Additional. We won't concern ourselves with the Authority or Additional sections, as they are not needed for typical DNS queries.

DNS message header format

The header is exactly 12 bytes long and is exactly the same for a DNS query or DNS response. The Header Format is illustrated graphically in the following diagram: see image

As the preceding diagram illustrates, the DNS message header contains 13 fields— ID, QR, OPCODE, AA, TC, RD, RA, Z, RCODE, QDCOUNT, ANCOUNT, NSCOUNT, and ARCOUNT:

ID is any 16-bit value that is used to identify the DNS message. The client is allowed to put any 16 bits into the DNS query, and the DNS server copies those same 16 bits into the DNS response ID. This is useful to allow the client to match up which response is in reply to which query, in cases where the client is sending multiple queries.

QR is a 1-bit field. It is set to 0 to indicate a DNS query or 1 to indicate a DNS response.

Opcode is a 4-bit field, which specifies the type of query. 0 indicates a standard query. 1 indicates a reverse query to resolve an IP address into a name. 2 indicates a server status request. Other values (3 through 15) are reserved.

AA indicates an authoritative answer.

TC indicates that the message was truncated. In this case, it should be re-sent using TCP.

RD should be set if recursion is desired. We leave this bit set to indicate that we want the DNS server to contact additional servers until it can complete our request.

RA indicates in a response whether the DNS server supports recursion. 

Z is unused and should be set to 0.

RCODE is set in a DNS response to indicate the error condition. Its possible values are as follows:

RCODE       Description
0           No error
1           Format error
2           Server failure
3           Name error
4           Not implemented
5           Refused

QDCOUNT (question count), ANCOUNT (answer count), NSCOUNT (name server count), and ARCOUNT (additional count) indicate the number of records in their corresponding sections. QDCOUNT indicates the number of questions in a DNS query. It is interesting that QDCOUNT is a 16-bit value capable of storing large numbers, and yet no real-world DNS server allows more than one question per message. ANCOUNT indicates the number of answers, and it is common for a DNS server to return multiple answers in one message.

Question format

The DNS Question Format consists of a name followed by two 16-bit values—QTYPE and QCLASS. This Question Format is illustrated as follows: see image

QTYPE indicates the record type we are asking for, and QCLASS should be set to 1 to indicate the internet.
The name field involves a special encoding. First, a hostname should be broken up into its individual labels. For example, www.example.com would be broken up into www, example, and com. Then, each label should be prepended with 1 byte, indicating the label length. Finally, the entire name ends with a 0 byte.

Visually, the name www.example.com is encoded as follows: see image

If the QTYPE and QCLASS fields were appended to the preceding name example, then it could make up an entire DNS question.

A DNS response is sometimes required to repeat the same name multiple times. In this case, a DNS server may encode a pointer to an earlier name instead of sending the same name multiple times. A pointer is indicated by a 16-bit value with the two most significant bits set. The lower 14 bits indicate the pointer value. This 14-bit value specifies the location of the name as an offset from the beginning of the message. Having the two most significant bits reserved has an additional side-effect of limiting labels to 63 characters. A longer name would require setting both high bits in the label length specifier, but if both high bits are set, it indicates a pointer and not a label length!

The answer format is similar to the question format but with a few more fields. Let's look at that next.

Answer format

The DNS answer format consists of the same three fields that questions have; namely, a name followed by a 16-bit TYPE and a 16-bit CLASS. The answer format then has a 32-bit TTL field. This field specifies how many seconds the answer is allowed to be cached for. TTL is followed by a 16-bit length specifier, RDLENGTH, followed by data. The data is RDLENGTH long, and the data's interpretation is dependent upon the type specified by TYPE.

Visually, the answer format is shown in the following diagram: see image

Keep in mind that most DNS servers use name pointers in their answer names. This is because the DNS response will have already included the relevant name in the question section. The answer can simply point back to that, rather than encoding the entire name a second (or third) time.

Whenever sending binary data over the network, the issue of byte order becomes relevant. Let's consider this now.

Endianness

The term endianness refers to the order in which individual bytes are stored in memory or sent over a network.

Whenever we read a multi-byte number from a DNS message, we should be aware that it's in big-endian format (or so-called network byte order). The computer you're using likely uses little-endian format, although we are careful to write our code in an endian- independent manner throughout this book. We accomplish this by avoiding the conversion of multiple bytes directly to integers, and instead we interpret bytes one at a time.

For example, consider a message with a single 8-bit value, such as 0x05. We know that the value of that message is 5. Bytes are sent atomically over a network link, so we also know that anyone receiving our message can unambiguously interpret that message as 5.

The issue of endianness comes into play when we need more than one byte to store our number. Imagine that we want to send the number 999. This number is too big to fit into 1 byte, so we have to break it up into 2 bytes—a 16-bit value. Because 999 = (3 * (2^8)) + 231, we know that the high-order byte stores 3 while the low-order byte stores 231. In hexadecimal, the number 999 is 0x03E7. The question is whether to send the high-order or the low-order byte over the network first.

Network byte order, which is used by the DNS protocol, specifies that the high-order byte is sent first. Therefore, the number 999 is sent over the network as a 0x03 followed by 0xE7.

A simple DNS query

To perform a simple DNS query, we would put an arbitrary number into ID, set the RD bit to 1, and set QDCOUNT to 1. We would then add a question after the header. That data would be sent as a UDP packet to port 53 of a DNS server.

A hand-constructed DNS for example.com in C is as follows:

char dns_query[] = {0xAB, 0xCD,                           /* ID */                     
                    0x01, 0x00,                           /* Recursion */                     
                    0x00, 0x01,                           /* QDCOUNT */                     
                    0x00, 0x00,                           /* ANCOUNT */                     
                    0x00, 0x00,                           /* NSCOUNT */                     
                    0x00, 0x00,                           /* ARCOUNT */                     
                    7, 'e', 'x', 'a', 'm', 'p', 'l', 'e', /* label */                     
                    3, 'c', 'o', 'm',                     /* label */                     
                    0,                                    /* End of name */                     
                    0x00, 0x01,                           /* QTYPE = A */                     
                    0x00, 0x01                            /* QCLASS set to 1 to indicate the internet */                     
                    };

This data could be sent as is to a DNS server over port 53.

The DNS server, if successful, sends a UDP packet back as a response. This packet has ID set to match our query. QR is set to indicate a response. QDCOUNT is set to 1, and our original question is included. ANCOUNT is some small positive integer that indicates the number of answers included in the message.

A DNS query program

We will now implement a utility to send DNS queries to a DNS server and receive the DNS response.

This should not normally be needed in the field. It is, however, a good opportunity to better understand the DNS protocol and to get experience of sending binary UDP packets.

We begin with a function to print a name from a DNS message.

Printing a DNS message name

DNS encodes names in a particular way. Normally, each label is indicated by its length, followed by its text. A number of labels can be repeated, and then the name is terminated with a single 0 byte.

If a length has its two highest bits set (that is, 0xc0), then it and the next byte should be interpreted as a pointer instead.

We must also be aware at all times that the DNS response from the DNS server could be ill-formed or corrupted. We must try to write our program in such a way that it won't crash if it receives a bad message. This is easier said than done.

The declaration for our name-printing function looks like this:

/*dns_query.c*/
const unsigned char *print_name(const unsigned char *msg, const unsigned char *p, const unsigned char *end);

We take msg to be a pointer to the message's beginning, p to be a pointer to the name to print, and end to be a pointer to one past the end of the message. end is required so that we can check that we're not reading past the end of the received message. msg is required for the same reason, but also so that we can interpret name pointers.

Inside the print_name function, our code checks that a proper name is even possible. Because a name should consist of at least a length and some text, we can return an error if p is already within two characters of the end. The code for that check is as follows:

/*dns_query.c*/
    if (p + 2 > end) {
        fprintf(stderr, "End of message.\n"); exit(1);
    }

We then check to see if p points to a name pointer. If it does, we interpret the pointer and call print_name recursively to print the name that is pointed to. The code for this is as follows:

/*dns_query.c*/
    if ((*p & 0xC0) == 0xC0) {
        const int k = ((*p & 0x3F) << 8) + p[1];
        p += 2;
        printf(" (pointer %d) ", k);
        print_name(msg, msg+k, end);
        return p;

Note that 0xC0 in binary is 0b11000000. We use (*p & 0xC0) == 0xC0 to check for a name pointer. In that case, we take the lower 6 bits of *p and all 8 bits of p[1] to indicate the pointer. We know that p[1] is still within the message because of our earlier check that p was at least 2 bytes from the end. Knowing the name pointer, we can pass a new value of p to print_name().

If the name is not a pointer, we simply print it one label at a time. The code for printing the name is as follows:

/*dns_query.c*/
    } else {
        const int len = *p++;
        if (p + len + 1 > end) {
            fprintf(stderr, "End of message.\n"); 
            exit(1);}
        printf("%.*s", len, p);
        p += len;
        if (*p) {
            printf(".");
            return print_name(msg, p, end);         
            } else {
            return p+1;         }
    }

In the preceding code, *p is read into len to store the length of the current label. We are careful to check that reading len + 1 bytes doesn't put us past the end of the buffer. We can then print the next len characters to the console. If the next byte isn't 0, then the name is continued, and we should print a dot to separate the labels. We call print_name() recursively to print the next label of the name.

If the next byte is 0, then that means the name is finished and we return. That concludes the print_name() function.

Now we will devise a function that prints an entire DNS message.

Printing a DNS message

Using print_name() that we have just defined, we can now construct a function to print an entire DNS message to the screen. DNS messages share the same format for both the request and the response, so our function is able to print either.

The declaration for our function is as follows:

/*dns_query.c*/
void print_dns_message(const char *message, int msg_length);

print_dns_message() takes a pointer to the start of the message, and an int data type indicates the message's length.

Inside print_dns_message(), we first check that the message is long enough to be a valid DNS message. Recall that the DNS header is 12 bytes long. If a DNS message is less than 12 bytes, we can easily reject it as an invalid message. This also ensures that we can read at least the header without worrying about reading past the end of the received data.

The code for checking the DNS message length is as follows:

/*dns_query.c*/
    if (msg_length < 12) {
        fprintf(stderr, "Message is too short to be valid.\n");
        exit(1);
    }

We then copy the message pointer into a new variable, msg. We define msg as an unsigned char pointer, which makes certain calculations easier to work with.

*dns_query.c*/
    const unsigned char *msg = (const unsigned char *)message;

If you want to print out the entire raw DNS message, you can do that with the following code:

/*dns_query.c*/
    int i;
    for (i = 0; i < msg_length; ++i) {
        unsigned char r = msg[i];
        printf("%02d:   %02X  %03d  '%c'\n", i, r, r, r);
    }
    printf("\n");

Be aware that running the preceding code will print out many lines. This can be annoying, so I would recommend using it only if you are curious about seeing the raw DNS message.

The message ID can be printed very easily. Recall that the message ID is simply the first two bytes of the message. The following code prints it in a nice hexadecimal format:

printf("ID = %0X %0X\n", msg[0], msg[1]);

Next, we get the QR bit from the message header. This bit is the most significant bit of msg[2]. We use the bitmask 0x80 to see whether it is set. If it is, we know that the message is a response; otherwise, it's a query. The following code reads QR and prints a corresponding message:

const int qr = (msg[2] & 0x80) >> 7;
printf("QR = %d %s\n", qr, qr ? "response" : "query");

The OPCODE, AA, TC, and RD fields are read in much the same way as QR. The code for printing them is as follows:

/*dns_query.c*/
    const int opcode = (msg[2] & 0x78) >> 3;
    printf("OPCODE = %d ", opcode);
    switch(opcode) {
        case 0: printf("standard\n"); break;
        case 1: printf("reverse\n"); break;
        case 2: printf("status\n"); break;
        default: printf("?\n"); break;
    }
    const int aa = (msg[2] & 0x04) >> 2;
    printf("AA = %d %s\n", aa, aa ? "authoritative" : "");
    const int tc = (msg[2] & 0x02) >> 1;
    printf("TC = %d %s\n", tc, tc ? "message truncated" : "");
    const int rd = (msg[2] & 0x01);
    printf("RD = %d %s\n", rd, rd ? "recursion desired" : "");

Finally, we can read in RCODE for response-type messages. Since RCODE can have several different values, we use a switch statement to print them. Here is the code for that:

if (qr) {
    const int rcode = msg[3] & 0x07;
    printf("RCODE = %d ", rcode);
    switch(rcode) {
        case 0: printf("success\n"); break;             
        case 1: printf("format error\n"); break;             
        case 2: printf("server failure\n"); break;             
        case 3: printf("name error\n"); break;             
        case 4: printf("not implemented\n"); break;
        case 5: printf("refused\n"); break;             
        default: printf("?\n"); break; 
    }
    if (rcode != 0) return;     
}

The next four fields in the header are the question count, the answer count, the name server count, and the additional count. We can read and print them in the following code:

const int qdcount = (msg[4] << 8) + msg[5];     
const int ancount = (msg[6] << 8) + msg[7];     
const int nscount = (msg[8] << 8) + msg[9];     
const int arcount = (msg[10] << 8) + msg[11];
    
printf("QDCOUNT = %d\n", qdcount);     
printf("ANCOUNT = %d\n", ancount);     
printf("NSCOUNT = %d\n", nscount);     
printf("ARCOUNT = %d\n", arcount);

That concludes reading the DNS message header (the first 12 bytes).

Before reading the rest of the message, we define two new variables as follows:

const unsigned char *p = msg + 12;
const unsigned char *end = msg + msg_length;

In the preceding code, the p variable is used to walk through the message. We set the end variable to one past the end of the message. This is to help us detect whether we're about to read past the end of the message – a situation we certainly wish to avoid!

We read and print each question in the DNS message with the following code:

if (qdcount) {
    int i;
    for (i = 0; i < qdcount; ++i) {
        if (p >= end) {
            fprintf(stderr, "End of message.\n"); 
            exit(1);
        }
        printf("Query %2d\n", i + 1);             
        printf("  name: ");
        p = print_name(msg, p, end); 
        printf("\n");

        if (p + 4 > end) {
            fprintf(stderr, "End of message.\n"); 
            exit(1);
        }
        const int type = (p[0] << 8) + p[1];             
        printf("  type: %d\n", type);             
        p += 2;
        const int qclass = (p[0] << 8) + p[1];             
        printf(" class: %d\n", qclass);             
        p += 2;
    }     
}

Although no real-world DNS server will accept a message with multiple questions, the DNS RFC does clearly define the format to encode multiple questions. For that reason, we make our code loop through each question using a for loop. First, the print_name() function, which we defined earlier, is called to print the question name. We then read in and print out the question type and class.

Printing the answer, authority, and additional sections is slightly more difficult than the question section. These sections start the same way as the question section – with a name, a type, and a class. The code for reading the name, type, and class is as follows:

if (ancount || nscount || arcount) {
    int i;
    for (i = 0; i < ancount + nscount + arcount; ++i) {             
        if (p >= end) {
            fprintf(stderr, "End of message.\n"); 
            exit(1);
        }

        printf("Answer %2d\n", i + 1);
        printf("  name: ");
        p = print_name(msg, p, end); 
        printf("\n");

        if (p + 10 > end) {
            fprintf(stderr, "End of message.\n"); 
            exit(1);
        }

        const int type = (p[0] << 8) + p[1];             
        printf("  type: %d\n", type);             
        p += 2;

        const int qclass = (p[0] << 8) + p[1];             
        printf(" class: %d\n", qclass);             
        p += 2;

Note that, in the preceding code, we stored the class in a variable called qclass. This is to be nice to our C++ friends, who are not allowed to use class as a variable name.

We then expect to find a 16-bit TTL field, and a 16-bit data length field. The TTL field tells us how many seconds we are allowed to cache an answer for. The data length field tells us how many bytes of additional data are included for the answer. We read TTL and the data length in the following code:

const unsigned int ttl = (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3];
printf(" ttl: %u\n", ttl);
p += 4;
const int rdlen = (p[0] << 8) + p[1];
printf(" rdlen: %d\n", rdlen);
p += 2;

Before we can read in the data of the rdlen length, we should check that we won't read past the end of the message. The following code achieves that:

if (p + rdlen > end) {
    fprintf(stderr, "End of message.\n"); 
    exit(1);
    }

We can then try to interpret the answer data. Each record type stores different data. We need to write code to display each type. For our purposes, we limit this to the A, MX, AAAA, TXT, and CNAME records. The code to print each type is as follows:

if (rdlen == 4 && type == 1) { /* A Record */                 
    printf("Address ");
    printf("%d.%d.%d.%d\n", p[0], p[1], p[2], p[3]);
} else if (type == 15 && rdlen > 3) { /* MX Record */                 
    const int preference = (p[0] << 8) + p[1];                 
    printf("  pref: %d\n", preference);                 
    printf("MX: ");
    print_name(msg, p+2, end); printf("\n");
} else if (rdlen == 16 && type == 28) { /* AAAA Record */                 
    printf("Address ");
    int j;
    for (j = 0; j < rdlen; j+=2) {
        printf("%02x%02x", p[j], p[j+1]);                     
        if (j + 2 < rdlen) 
            printf(":");
    }
    printf("\n");
} else if (type == 16) { /* TXT Record */                 
    printf("TXT: '%.*s'\n", rdlen-1, p+1);
} else if (type == 5) { /* CNAME Record */                 
    printf("CNAME: ");                 
    print_name(msg, p, end); 
    printf("\n");             
}
p += rdlen;

We can then finish the loop. We check that all the data was read and print a message if it wasn't. If our program is correct, and if the DNS message is properly formatted, we should have read all the data with nothing left over. The following code checks this:

    }
}

if (p != end) {
    printf("There is some unread data left over.\n");     
}
printf("\n");

}

That concludes the print_dns_message() function.

We can now define our main() function to create the DNS query, send it to a DNS server, and await a response.

Sending the query

We start main() with the following code:

int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Usage:\n\tdns_query hostname type\n");         
        printf("Example:\n\tdns_query example.com aaaa\n");         
        exit(0);
    }

    if (strlen(argv[1]) > 255) {         
        fprintf(stderr, "Hostname too long.");         
        exit(1);
    }

The preceding code checks that the user passed in a hostname and record type to query. If they didn't, it prints a helpful message. It also checks that the hostname isn't more than 253 characters long. Hostnames longer than that aren't allowed by the DNS standard, and checking it now ensures that we don't need to allocate too much memory.

We then try to interpret the record type requested by the user. We support the following options – a, aaaa, txt, mx, and any. The code to read in those types and store their corresponding DNS integer value is as follows:

unsigned char type;
if (strcmp(argv[2], "a") == 0) {
    type = 1;
} else if (strcmp(argv[2], "mx") == 0) {
    type = 15;
} else if (strcmp(argv[2], "txt") == 0) {
    type = 16;
} else if (strcmp(argv[2], "aaaa") == 0) {
    type = 28;
} else if (strcmp(argv[2], "any") == 0) {
    type = 255;
} else {
    fprintf(stderr, "Unknown type '%s'. Use a, aaaa, txt, mx, or any.", argv[2]);
    exit(1);
}

Like all of our previous programs, we need to initialize Winsock. The code for that is as follows:

#if defined(_WIN32)
    WSADATA d;
    if (WSAStartup(MAKEWORD(2, 2), &d)) {         
        fprintf(stderr, "Failed to initialize.\n");         
        return 1;
    } 
#endif

Our program connects to 8.8.8.8, which is a public DNS server run by Google. Refer to Chapter 1,  An Introduction to Networks and Protocols, Domain Names, for a list of additional public DNS servers you can use.

Recall that we are connecting on UDP port 53. We use getaddrinfo() to set up the required structures for our socket with the following code:

printf("Configuring remote address...\n");
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));
hints.ai_socktype = SOCK_DGRAM;
struct addrinfo *peer_address;
if (getaddrinfo("8.8.8.8", "53", &hints, &peer_address)) {         
    fprintf(stderr, "getaddrinfo() failed. (%d\n", GETSOCKETERRNO());         
    return 1;
}

We then create our socket using the data returned from getaddrinfo(). The following code does that:

printf("Creating socket...\n");
SOCKET socket_peer;
socket_peer = socket(peer_address->ai_family, peer_address->ai_socktype, peer_address->ai_protocol);     
if (!ISVALIDSOCKET(socket_peer)) {
    fprintf(stderr, "socket() failed. (%d)\n", GETSOCKETERRNO());         
    return 1;
}

Our program then constructs the data for the DNS query message. The first 12 bytes compose the header and are known at compile time. We can store them with the following code:

char query[1024] = {0xAB, 0xCD, /* ID */                         
                    0x01, 0x00, /* Set recursion */                         
                    0x00, 0x01, /* QDCOUNT */                         
                    0x00, 0x00, /* ANCOUNT */                         
                    0x00, 0x00, /* NSCOUNT */                         
                    0x00, 0x00 /* ARCOUNT */};

The preceding code sets our query's ID to 0xABCD, sets a recursion request, and indicates that we are attaching 1 question. As mentioned earlier, 1 is the only number of questions supported by real-world DNS servers.

We then need to encode the user's desired hostname into the query. The following code does that:

char *p = query + 12;
char *h = argv[1];
while(*h) {
    char *len = p;
    p++;
    if (h != argv[1]) 
        ++h;
    while(*h && *h != '.') 
        *p++ = *h++;
    *len = p - len - 1;
}
*p++ = 0;

The preceding code first sets a new pointer, p, to the end of the query header. We will be adding to the query starting at p. We also define a pointer, h, which we use to loop through the hostname.

We can loop while *h != 0 because *h is equal to zero when we've finished reading the hostname. Inside the loop, we use the len variable to store the position of the label beginning. The value in this position needs to be set to indicate the length of the upcoming label. We then copy characters from *h to *p until we find a dot or the end of the hostname. If either is found, the code sets *len equal to the label length. The code then loops into the next label.

Finally, outside the loop, we add a terminating 0 byte to finish the name section of the question.
We then add the question type and question class to the query with the following code:

*p++ = 0x00; *p++ = type; /* QTYPE */     
*p++ = 0x00; *p++ = 0x01; /* QCLASS */

We can then calculate the query size by comparing p to the query beginning. The code for figuring the total query size is as follows:

const int query_size = p - query;

Now, with the query message formed, and its length known, we can use sendto() to transmit the DNS query to the DNS server. The code for sending the query is as follows:

int bytes_sent = sendto(socket_peer, query, query_size, 0, peer_address->ai_addr, peer_address->ai_addrlen);
printf("Sent %d bytes.\n", bytes_sent);

For debugging purposes, we can also display the query we sent with the following code:

print_dns_message(query, query_size);

The preceding code is useful to see whether we've made any mistakes in encoding our query.

Now that the query has been sent, we await a DNS response message using recvfrom(). In a practical program, you may want to use select() here to time out. It could also be wise to listen for additional messages in the case that an invalid message is received first.

The code to receive and display the DNS response is as follows:

char read[1024];
int bytes_received = recvfrom(socket_peer, read, 1024, 0, 0, 0);
printf("Received %d bytes.\n", bytes_received);
print_dns_message(read, bytes_received);     
printf("\n");

We can finish our program by freeing the address(es) from getaddrinfo() and cleaning up Winsock. The code to complete the main() function is as follows:

freeaddrinfo(peer_address);
    CLOSESOCKET(socket_peer);
#if defined(_WIN32)
    WSACleanup();
#endif
    return 0;
}

That concludes the dns_query program.