Algorithms have 3 charcateristics:
1. effective computability means each step can be carried out by a computer.
2. finiteness means that a procedure terminates.
3. definiteness means that each step is precisely stated.

ISA specifies the interface between a computer program and the computer hardware that will be 
responsible for executing the instructions. Opcode refers to instructions e.g mul and operand
refers to a data value that is operated on.

There are many ISA's in existence. Each specifies a different number of opcodes, operands and 
addressing modes from the rest.

The automobile ISA describes what a driver needs to know as he/she sits inside an automobile 
in order for it to carry out the driver's wishes. All automobiles have the same ISA therefore
drivers do not need to acquire different driving licenses for different automobiles.

The microarchitecture (or implementation) of an automobile's ISA is about what goes on underneath the hood. Here all automobiles brands and models can be different depending on the
cost/performance tradeoffs the designer made before the car was manufactured.

Each microarchitecture is an opportunity for computer designers to make different tradeoffs
between the cost of the microprocessor, the performance that it will provide, and the energy that it will consume.

The following are the transformations that need to happen in order for computers to be used to 
solve a problem when electron move across a voltage potential:

Problem expressed in natural language -> algorithm -> program -> ISA -> microarchitecture ->
logic circuits -> the devices  (cmos circuits, nmos circuits and gallium arsenide circuits)

At each level of transformation there are choices on how to proceed which determine the resulting cost and performance of the computer.

Data type: a particular representation of information is termed as a data type if there are operations inside of a computer that can operate on the information that is encoded in that representation.

signed magnitude and 1'complement data types require unnecessarily cumbersome hardware to do addition. on the other hand, the circuitry required to add 2 integers using 2's complement data type is much simpler

manual conversion of decimal fraction (e.g. 0.421) to binary requires the following steps:
see decimalFractionToBinary1.png and decimalFractionToBinary2.png

manual conversion of binary fraction to decimal requires the following steps: see binaryFractionToDecimal.png

manual conversion of decimal to 2's complement can be achieved by following these steps see decimalTo2scomplement.png

I don't understand how they arrived at this result see 2sComplementSubtraction.png!!

The value of a positive number does not change if we extend the sign bit 0 as many bit positions to the left as desired. Similarly, the value of a negative number does not change by extending the sign bit 1 as many bit positions to the left as desired. Since in both cases it is the sign bit that is extended, we refer to the operation as Sign-EXTension, often abbreviated SEXT. Sign-extension is performed in order to be able to operate on representations of diﬀerent lengths. It does not aﬀect the values of the numbers being represented.

overflow in unsigned arithmetic is relatively straightforward because it results in overflow of the msb meaning that the result is less than the value of one of the numbers that was added.

overflow in signed numbers during arithmetic is easy to test for because the msb overflows and becomes 0 which means that the number becomes positive. In contrast, when adding two positive signed numbers, overflow occurs when the msb is turned on meaning that the result becomes negative.

Suppose we wish to know if two patterns are identical. Since the XOR function pro-
duces a 0 only if the corresponding pair of bits is identical, two patterns are identical
if the output of the XOR is all 0s.

Floating Point Data Type (Greater Range, Less Precision): Most ISAs today specify more than one ﬂoating point data type. One of them, usually called ﬂoat, consists of 32 bits, allocated as follows:

1 bit for the sign (positive or negative)
8 bits for the range (the exponent ﬁeld)
23 bits for precision (the fraction ﬁeld)

Normalized Form; the ﬂoating point data type represents numbers expressed in scientiﬁc notation, and mostly in normalized form:

N = (−1)^S × 1. fraction × 2^(exponent−127), 1 ≤ exponent ≤ 254

where S, fraction, and exponent are binary numbers.

We say mostly in normalized form because (as noted in the equation) the data type represents a ﬂoating point number in normalized form only if the eight-bit exponent is restricted to the 254 unsigned integer values, 1 (00000001) through 254 (11111110).

As you know, with eight bits, one can represent 256 values uniquely. For the other two integer values 0 (00000000) and 255 (11111111), the ﬂoating point data type does not represent normalized numbers.

