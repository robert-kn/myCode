Algorithms have 3 charcateristics:
1. effective computability means each step can be carried out by a computer.
2. finiteness means that a procedure terminates.
3. definiteness means that each step is precisely stated.

ISA specifies the interface between a computer program and the computer hardware that will be 
responsible for executing the instructions. Opcode refers to instructions e.g mul and operand
refers to a data value that is operated on.

There are many ISA's in existence. Each specifies a different number of opcodes, operands and 
addressing modes from the rest.

The automobile ISA describes what a driver needs to know as he/she sits inside an automobile 
in order for it to carry out the driver's wishes. All automobiles have the same ISA therefore
drivers do not need to acquire different driving licenses for different automobiles.

The microarchitecture (or implementation) of an automobile's ISA is about what goes on underneath the hood. Here all automobiles brands and models can be different depending on the
cost/performance tradeoffs the designer made before the car was manufactured.

Each microarchitecture is an opportunity for computer designers to make different tradeoffs
between the cost of the microprocessor, the performance that it will provide, and the energy that it will consume.

The following are the transformations that need to happen in order for computers to be used to 
solve a problem when electron move across a voltage potential:

Problem expressed in natural language -> algorithm -> program -> ISA -> microarchitecture ->
logic circuits -> the devices  (cmos circuits, nmos circuits and gallium arsenide circuits)

At each level of transformation there are choices on how to proceed which determine the resulting cost and performance of the computer.

Data type: a particular representation of information is termed as a data type if there are operations inside of a computer that can operate on the information that is encoded in that representation.

signed magnitude and 1'complement data types require unnecessarily cumbersome hardware to do addition. on the other hand, the circuitry required to add 2 integers using 2's complement data type is much simpler

manual conversion of decimal fraction (e.g. 0.421) to binary requires the following steps:
see decimalFractionToBinary1.png and decimalFractionToBinary2.png

manual conversion of binary fraction to decimal requires the following steps: see binaryFractionToDecimal.png

manual conversion of decimal to 2's complement can be achieved by following these steps see decimalTo2scomplement.png

I don't understand how they arrived at this result see 2sComplementSubtraction.png!!

The value of a positive number does not change if we extend the sign bit 0 as many bit positions to the left as desired. Similarly, the value of a negative number does not change by extending the sign bit 1 as many bit positions to the left as desired. Since in both cases it is the sign bit that is extended, we refer to the operation as Sign-EXTension, often abbreviated SEXT. Sign-extension is performed in order to be able to operate on representations of diﬀerent lengths. It does not aﬀect the values of the numbers being represented.

overflow in unsigned arithmetic is relatively straightforward.

