{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\froman\fcharset0 Times-Roman;\f2\fmodern\fcharset0 Courier-Bold;
\f3\fswiss\fcharset0 Helvetica;\f4\fmodern\fcharset0 CourierNewPSMT;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww33100\viewh17300\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs36 \cf0 Rules to follow when writing software:\
1. Clarity is one of the most important qualities of well written code.\
2. Write DRY (do not repeat yourself) code. The opposite of DRY code is WET (we enjoy typing) code. Not adhering to DRY code increases the probability of \
   making mistakes.\
3. Write code after you have written the steps of the solution.\
4. Developing software != coding. Coding means typing statements in a text editor - it is a part of software development. Before typing a single line of \
   code you first need to know why you are developing the software.\
\
	Before coding:\
\
		(a) read the specification and understand the requirements\
		(b) consider possible inputs and expected outputs\
		(c) identify valid but unexpected inputs and the correct outputs\
		(d) identify invalid inputs and the ways to detect them\
		(e) think about the solution and sketch an approach on paper\
		(f) draw block diagrams showing how information is exchanged among different parts of the program\
		(g) after you have a design, plan the implementation aspect of the program I.e. how many functions should be created? What does each function do?  \
           How many files are needed? When designing functions try to keep the following suggestions in mind:\
				(i) each function should only do one thing\
				(ii)each function should not consist of more than 40 lines of code (the number is not rigid, 45 is alright. 120 are too many). A general \
                  rule is that the entire function should fit in a computer screen using readable font size.\
		(h) having a detailed design will save time on coding and debugging\
\
	During coding:\
\
		(a) always use a text editor that automatically indents amongst other things.\
		(b) read your code line by line before running any test cases. This can help you find problems that are difficult to find by testing.\
		(c) if you want to finish programs correctly and faster, write more code. Before integrating code into a larger program. Write a small program to \
           test your solution. This is called a unit test. If you cannot make one function work, you will definitely be incapable of of making anything \
           work after putting many functions together.\
		(d) avoid copying and pasting code\
		(e) resolve all compiler warnings. Many studies have shown that warnings are likely to be serious errors even though they are not syntax errors.\
\
\
\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf2 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs36 \cf0 \kerning1\expnd0\expndtw0 My current MacBook Pro has 32 GB of volatile storage. 1 GB is equal to 10^(9) bytes which means that it has 32 billion bytes of volatile storage. Since 1 byte is made up of 8 bits (which can either have a value of 1 or 0), then it has 32 x 10^(9) x 8 = 256 billion bits of volatile storage.
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
\

\f0\fs36 \cf0 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f2\b \cf0 Every non zero value corresponds to true while 0 corresponds to false.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b0 \cf0 Storage in a computer can be divided into volatile and non volatile storage. Volatile storage requires electricity and therefore can only store data when a computer is turned on. Volatile storage is usually referred to as \'93memory\'94. Non volatile storage persists when a computer is turned off or rebooted. Examples include, flash memory or hard disks. Flash memory is also called a solid state disk or SSD.\
\
A computers memory is organised into address-values pairs. Operating systems guarantee that each piece of data has a unique and positive address. The address is never zero or negative. The symbol NULL is defined as the zero address and indicates an invalid address. As it is impossible to remember for example 32 billion volatile storage addresses in the case of my MacBook Pro, early computer science pioneers created symbols to associate to memory. If the value stored at an address corresponding to a particular symbol may change during program execution, the symbol is called a variable. These symbols have meaning to humans writing computer programs. Compilers such as clang convert these symbols into addresses. The final computer program manipulates the values - it does not see the symbols. Consequently, inside a computers memory there are only addresses and values.\
\
Modern computers usually organise volatile memory into three types:\
	1. Stack memory (call stack): store data and follow FILO. It is automatically managed by the code generated by the compiler\
	2. Heap memory: store data\
	3. Program memory: stores machine code of computer programs\
\
\
The rules for the call stack can be summarised as follows:\
\
	1. When a function is called, the line number after this call is pushed onto the call stack. This line number is the RL. The program will continue \
      From this location after the called function finishes (I.e. returns)\
\
	2. If a function returns a value, the value is written to a local variable in the caller\'92s frame. This variable\'92s address (called the value address) \
       is stored in the call stack.\
\
	2. If a function has arguments then the arguments are stored above the return location (and VA is there is one)\
\
	3. The arguments and the return location together form the frame of the called function. A frame occupies a contiguous chunk of memory.\
\
	4. If a function has local variables, then the local variables are stored above the arguments.\
\
	4. If the same function is called from multiple lines, then each call has a corresponding return location (the line after each function call)\
\
	5. When a function finishes, the program continues from the line number stored at the top of the call stack. The top of the call stack is then \
      Popped.\
\
\
The keyword return can be used for two different purposes:\
\
	1. If void is in front of a function name, the function does not return any value. The word return stops the function and the program continues from \
       the return location in the caller.\
\
	2. If the function is not void, the word return assigns a value to the variable given by the value address in the call stack.\
\
\
Executing a return statement stops a function, resulting in its frame being popped off the call stack. Anything after return is ignored. The program then continues from the return location.\
\
\
If you want to initialise an array of ints to zero, do the following:\
\
	1. Int arr[10] = \{0\};\
\
\
You don\'92t have to explicitly give a size when creating an array on the stack I.e. the compiler will automatically infer it:\
\
	1. Int arr[] = \{1,2,3,4\}.  \'97> compiler will infer that 4 objects are in the array\
\
\
You can retrieve an object\'92s address by adding & in front of it. This address can be printed using with the printf functions using the format specifier %p.\
\
\
Every time a function is called, a new frame is pushed to the call stack. A function can see only its own frame/scope (a new scope is created every time a pair of \{ \} is encountered. Since computers only work with addresses and values, two functions can have the same symbols but they wouldn\'92t get mixed up when the program containing them runs. Additionally, a function may read from or write to memory addresses in lower frames; however a function can never look upward into memory above its frame. This is because whenever a function is actively executing, there are not valid memory addresses above it.\
\
\
The data display debugger (DDD) is a graphical user interface for the GDB debugger. You need to select an executable when you open a file. The debugger will automatically find the .c file based on the information that cc leaves in the executable when you initially run cc -g -Wall -Wshadow -Wextra <source-file-name> -o <executable>. This is useful when debugging a program with multiple source files. You can use the following commands after the gdb prompt: b <function-name> (to set a breakpoint), run (execute a program), continue (if you want to resume execution after a breakpoint is hit), bt (the backtrace allows you to view the call stack.  The beginning of each numbered line shows a frame corresponding to a function), f <number> (will display the. Corresponding frame).\
\
\
Printf is not part of the C language; there is no input or output defined in C itself. Printf is a useful function (amongst many others) from the standard library of functions that are normally accessible to C programs. The behaviour of these functions is defined in the ANSI standard, so its properties should be the same with any compiler and library that conforms to the standard.\
\
\
Symbolic constant names are conventionally written in uppercase so that they can be readily distinguished from lower case variable names.\
\
The model of input and output supported by the standard library is very simple. Text input or output, regardless of where it originates or where it goes to, is dealt with as streams of characters. A text stream is a sequence of characters divided into lines; each line consists of zero or more characters followed by a newline character. It is the responsibility of the library to make each input or output stream conform to this model; the C programmer using the library need not worry about how lines are represented outside the program.\
\
The standard library provides several functions for reading or writing one character at a time, of which getchar and putchar are the simplest. Each time it is called, getchar reads the next input character from a text stream and returns it as its value. Getchar returns a distinctive value when there is no more input, a value that cannot be confused with any real character. This value is called EOF. EOF is an integer defined in stdio.h, but the specific numeric value doesn\'92t matter as long as it is not the same as any char value. The function putchar prints a character each time it is called. \
\
Printf uses %f for both float and double; %.0f suppresses printing of the decimal point and the fractional part which is zero.\
\
A character written between two single quotes represents an integer value equal to the numerical value of the character in the machine\'92s character set. This is called a character constant.\
\
\
\
The keyword const can be applied in two different ways with different meanings when it comes to arrays. They are\
\
	1. If const appears before a data type then you aren\'92t allowed to change any of the elements in the array with new objects but it is permissible to \
      reassign the variable to point to a new memory address.\
	2. If const appears after a data type, you are allowed to reassign the elements in the array to new objects but you can\'92t reassign the variable to \
      point to a new address\
	3. If const appears before and after a data type then the compiler will not allow you to change the value at the memory address and neither will you \
      be able to reassign the pointer variable to a new memory address.\
\
\
Strings can be created by putting characters between double quotations. \'93Hello\'94 is a string constant (or character string) which means its data cannot be edited. In most cases, string variables are preferable to store strings whose values may change. C uses arrays of characters for strings. Every string is an array of characters but an array of characters is not necessarily a string. To be a string one element in the array must be the special character \'91\\0\'92 (null byte) i.e when storing a string of n characters the array needs space for n + 1 characters. This character terminates the string and is called the null terminator. It indicates the end of a string thus its length. If an array has characters after the null terminator, those characters are not part of the string.\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
Although C allows global variables, well written software almost always avoids global variables. The main problem is that global variables can be changed anywhere in a program. As a program becomes larger and more complex, it becomes increasingly harder to track the places where global variables may change.\
\
\
\
%c for characters, %d for integers, %f for floating point numbers, %s for strings, %ld for long decimals\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 {{\NeXTGraphic 1__#$!@%!#__Pasted Graphic.tiff \width20440 \height9180 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
\
\
 \
\
\
An array can be interpreted as a pointer whose value is the address of the first element of the array.\
\
	1. Arr == &Arr[0]\
\
In C programs, an array itself doesn\'92t provide information about the number of elements. The addresses of array elements are always contiguous.\
\
If you use an invalid index to access an array then the programs behaviour is undefined I.e. anything could happen and it will not be predictable. The the program will access a memory address that does not belong to the array.\
\
When a program stops with the message segmentation fault (core dumped) it means that the program intends to read from or write to a memory address that does not belong to the program. A program that has invalid memory accesses may create security vulnerability. Modern computers usually run many programs at once. Each program is given part of the memory. If one program tries to read from or write to a wrong address, the operating system \'93may\'94 stop the program. This protects other programs running on the same computer. Some programmers may think that accessing invalid memory is harmless as long as the programs do not have segmentation faults. This is wrong. Allowing invalid addresses is one of the most common security problems in software. It can allow a malicious program to hijack another program. If a program accesses invalid addresses, the program\'92s behaviour is not defined. \
\
Be careful about the word \'93may\'94 here. The operating system does not keep track of every memory address. Instead, the OS uses pages as a unit. The size of a page of memory varies on the operating system; 4KB is common. If the wrong address is within a page given to a program, then the OS will not stop the program. That means that a program may modify a variable within a valid page unintentionally without causing a segmentation fault. It is called a segmentation fault and not a page fault because some processors organise memory by variable sized segments. Page and segment may be used together; a segment may contain multiple pages. In fact, page fault is already used in the context of virtual memory. Thus the name segmentation fault remains. If the wrong address is outside the program\'92s segments then the OS will stop the program. \
\
The sizes of types are not fixed by the C language and can vary depending on the computer, operating system and specific compiler options chosen to compile the code.\
\
Storing memory addresses in integers is generally a very bad idea because it can lead subtle problems when the code is compiled under different circumstances.\
\
In linux, a program called valgrind can help detect problems of accessing invalid memory addresses. You can use it as follows:\
\
	valgrind --tool=memcheck --verbose ./<executable>  (or if you want the output to be redirected to a file instead of stdout)\
\
	valgrind --tool=memcheck --verbose --log-file=<name-of-file> ./<executable>\
\
	This will cause the program to be run within valgrind which in turn carefully checks every memory access to make sure that it is valid.\
\
In linux /dev/null is a special file that simply discards everything written to it. It is a black hole.\
\
The tool gcov works in collaboration with gcc in order to find lines that are never executed in a program. It requires additional arguments when running with gcc I.e.\
\
	cc -Wall -Wshadow -fprofile-arcs -ftest-coverage <c-file-name> -o <output-file>\
\
	Next run the <output-file> as such ./<output-file>\
\
	Two output files should be generated; <c-file-name>.gcda and <c-file-name>.gcno\
\
	Now you can run the gcov command as such; gcov <c-file-name>\
\
	Some output should be printed to stdout relating to the file executed, lines executed along with mentioning that another file has been created. This \
   newly created file when opened will mark the lines that could not be executed by #####.\
\
	If gcov reports that some lines are never executed, then the problem may come from the program. Sometimes, the problem comes from test inputs.\
\
In some cases, invalid memory access will cause a core dumped message. The core file is an old way to debug programs. It can occupy a lot of space on the disk. Use the following command to find whether a core file exists find . -name \'93core\'94. The system settings can be modified to eliminate cores using the following command limit coredumpsize 0 \
\
Char * * argv means pointer to pointers of characters/ array of strings. The first string in this array is argv[0] and the type is char *. The first letter of the first string is argv[0][0] and its type is char. Argv arguments are stored on the call stack\
\
Int argc means the number of arguments passed (including the main program)\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f3\fs24 \cf0 {{\NeXTGraphic 1__#$!@%!#__1__#$!@%!#__Pasted Graphic.tiff \width6480 \height1320 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs36 \cf0 \
argv[0] (prog), argv[1] (some), argv[2] (arguments) are stored as strings with each of them being a pointer storing the starting addresses of the first letter in each of those strings. The value of argv[0] is the address of argv[0][0] and so on\'85\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f3\fs24 \cf0 {{\NeXTGraphic 1__#$!@%!#__Pasted Graphic 2.tiff \width10620 \height16400 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs36 \cf0 \
\
The -c flag is used to tell the compiler to create an object file. \
\
The -o flag instructs the compiler to link objects file in order to create an executable\
\
The make program in linux takes a special input file whose name is Makefile. The main purpose of the Makefile is to decide which files need to be recompiled. The decisions are based on the modification time or date of the objects files and the relevant .c files. Anything after # is treated as a comment and ignored. When a program has been completed and is ready for customers, you want to replace the -g flag (for debugging) with the -O flag (for optimisation). Optimising a program can make it considerably faster. When make is typed on the cli, you are instructing the make program to check the first rule at the top of the Makefile (after any symbol definitions). You can tell make to use any file by adding -f name I.e.\
\
			make -f <name>\
\
According to the integer values assigned to the latin alphabet, if you want to calculate what distance a char is from another char, use the following syntax:\
\
	1. Char - \'91a\'92 or char - \'91A\'92\
\
Why create header files?\
	\
	1. Declare constants using the pre-processor directive #define \
	2. Declare functions\
	3. Define new data types\
\
What is the difference between data types?\
\
	1. The format of the data (the representation in computer memory differs).\
	2. The range of possible values and the size required to store the data. A 4 byte integer stores valid values that are between the range of \
      -2,147,483,648 (-2^31, approximately -10^9) and 2,147,483,647 (2^31 -1). In contrast, the absolute value of a double precision floating number (8 \
      bytes) can be as small as 10^(-308) and as large as 10^308 (approximately).	3. The effect of operations on the data. Because two data types have different formats, when a program performs an operation between the two, the \
      result depends on the types involved.\
\
When multiple pieces of data are organised together, it is called a structure (a new type). After creating a structure, the type can be used to create an object (borrowing a term from C++ and java). An object is a specific instance of a type. Each piece of data in an object is called an attribute. The typedef struct keywords are used to create new types in C. The structures name is given at the end of the structure, after \} and before ;. The keywords typedef struct inform the C compiler that a new type is being defined. It is common to have only one structure in a header file and the file\'92s name is the same as the structure\'92s name (but in lower case). \
\
The attributes of an object can be accessed using period notation. An object can be copied to another object of the same type. if the types in an object are of type integer, double etc, all of the attributes can be initialised to 0 by assigning the whole object to 0. If you want to compare two user defined objects, you have to write a function that compares the attributes. When passing an object as an argument, all attributes are copied to the argument of the called function. Assuming you have an object whose symbol is P and it has an attribute x, you can access that attribute in a separate function (that consumes the object as a pointer) using the syntax P -> x (or (*P).x)\
\
Each structure should have a constructor to initialise all attributes. If a structure has pointers for dynamically allocated memory, then it also needs a destructor.\
\
A deep copy allocates memory so that objects do no share memory, a shallow copy allows several objects attributes to point to the same addresses.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 {{\NeXTGraphic 1__#$!@%!#__1__#$!@%!#__1__#$!@%!#__Pasted Graphic.tiff \width19540 \height2940 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
To write binary data, fwrite is used. The return value is the number of objects written. This number can be different from the third argument. The data written by fwrite needs to be read by fread not fscanf.\
\
The memory allocation functions always return void pointers. This means that you need to cast the void pointer into the correct type for the data that will be stored in the reserved memory block.\
\
Malloc is used to reserve memory space in the heap. When allocating space in the heap using malloc, the type of pointer must match what is in sizeof(\'85). A program will behave strangely when types do not match. Programs should check whether malloc calls are successful. If it fails, then it is a NULL. Programs should handle this problem before doing anything else. Why should malloc fail? This happens when the system cannot provide the requested memory. When using malloc to allocate an array, the memory addresses of the elements are contiguous. When the memory is no longer needed the program must release the memory by calling free. If a program calls malloc without calling free, then the program has a memory leak. \
\
Here is a review of the relationships between arrays and pointers:\
	1. An array always means a pointer. The name of the array is the address of the first element.\
	2. A pointer is not necessarily an array\
\
How to create a 2-dimensional array on the heap:\
	1. type * * arr = malloc(n * sizeof(type *))\
	2. Write a loop where the loop counter is less than n and proceeds to initialise arr[I] = malloc(n * (sizeof(type))\
\
Testing can never guarantee that a program is correct because there are too many possible cases. Nevertheless it is important because it helps detect problems. Before writing a program or even a single function, you should think about how to test it
\f4 .\
\

\f0 In C, the function rand returns a pseudo random integer between 0 and the largest integer. You can increase the randomness of the integers generated by calling the function stand and setting its argument seed as the seed for a new sequence of pseudo random integers to be returned by the rand function. If no seed value is provided, the functions are automatically seeded with a value of 1 which will generate the same sequence of numbers. If the seed changes the sequence also changes. The time function (which returns the number of seconds since 00:00:00 January 1st 1970) can be set as the seed which will result in the seed changing every second and therefore will generate a sequence of random numbers.\
\
When a program calls scanf, the program waits for the user to enter data from the keyboard 
\f4 \
\
}