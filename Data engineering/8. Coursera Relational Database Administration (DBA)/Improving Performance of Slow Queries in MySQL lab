In this lab, you will learn how to improve the performance of your slow queries in MySQL, which can be particularly helpful with large databases.

Objectives
After completing this lab, you will be able to:

Use the EXPLAIN statement to check the performance of your query
Add indexes to improve the performance of your query
Apply other best practices such as using the UNION ALL clause to improve query performance

Database Used in this Lab

The Employees database used in this lab comes from the following source: https://dev.mysql.com/doc/employee/en/ under the CC BY-SA 3.0 License.

The following entity relationship diagram (ERD) shows the schema of the Employees database:

see employees-schema.png

The first row of each table is the table name, the rows with keys next to them indicate the primary keys, and the remaining rows are additional attributes.

Exercise 1: Load the Database

Let’s begin by retrieving the database and loading it so that it can be used.

To download the zip file containing the database, copy and paste the following into the Terminal:

wget https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DB0231EN-SkillsNetwork/datasets/employeesdb.zip

Next, we’ll need to unzip its contents. We can do that with the following command:

unzip employeesdb.zip

Now, let’s change directories so that we’re able to access the files in the newly created employeesdb folder.

cd employeesdb

import the data. You can do this by entering the following into the Terminal:

mysql --host=172.21.101.173 --port=3306 --user=root --password -t < employees.sql

Your data will now load. This may take a minute or so.

start the MySQL command-line interface

Recall that the name of the database that we’re using is Employees. To access it, we can use this command:

use employees;

Let’s see which tables are available in this database:

show tables;

In this database, there are 8 tables, which we can confirm with the database’s ERD.

Now that your database is all set up, let’s take a look at how we can check a query’s performance!

Exercise 2: Check Your Query's Performance with EXPLAIN

The EXPLAIN statement, which provides information about how MySQL executes your statement, will offer you insight about the number of rows your query is planning on looking through. This statement can be helpful when your query is running slow. For example, is it running slow because it’s scanning the entire table each time?

Let’s start with selecting all the data from the employees table:

SELECT * FROM employees;

We can use EXPLAIN to see how many rows were scanned:

EXPLAIN SELECT * FROM employees;

Notice how EXPLAIN shows that it is examining 298,980 rows, almost the entire table! With a larger table, this could result in the query running slowly.

So, how can we make this query faster? That’s where indexes come in!

Exercise 3: Add an Index to Your Table

To begin, let’s take at the existing indexes. We can do that by entering the following command:

SHOW INDEX FROM employees;

Remember that indexes for primary keys are created automatically, as we can see above. An index has already been created for the primary key, emp_no. If we think about this, this makes sense because each employee number is unique to the employee, with no NULL values.

Now, let’s say we wanted to see all the information about employees who were hired on or after January 1, 2000. We can do that with the query:

SELECT * FROM employees WHERE hire_date >= '2000-01-01';

As we can see, the 13 rows returned took about 0.17 seconds to execute. That may not seem like a long time with this table, but keep in mind that with larger tables, this time can vary greatly.

EXPLAIN SELECT * FROM employees WHERE hire_date >= '2000-01-01';

This query results in a scan of 299,423 rows, which is nearly the entire table!

By adding an index to the hire_date column, we’ll be able to reduce the query’s need to search through every entry of the table, instead only searching through what it needs.

You can add an index with the following:

CREATE INDEX hire_date_index ON employees(hire_date);

The CREATE INDEX command creates an index called hire_date_index on the table employees on column hire_date.

To check your index, you can use the SHOW INDEX command:

SHOW INDEX FROM employees;

Now you can see that we have both the emp_no index and hire_date index.

With the index added

Once more, let’s select all the employees who were hired on or after January 1, 2000.

SELECT * FROM employees WHERE hire_date >= '2000-01-01';

The difference is quite evident! Rather than taking about 0.17 seconds to execute the query, it takes 0.00 seconds—almost no time at all.

We can use the EXPLAIN statement to see how many rows were scanned:

EXPLAIN SELECT * FROM employees WHERE hire_date >= '2000-01-01';

Under rows, we can see that only the necessary 13 columns were scanned, leading to the improved performance.

Under Extra, you can also see that it has been explicitly stated that the index was used, that index being hire_date_index based on the possible_keys column.

Now, if you want to remove the index, enter the following into the Terminal:

DROP INDEX hire_date_index ON employees;

This will remove the hire_date_index on the employees table. You can check with the SHOW INDEX command to confirm:

Exercise 4: Use an UNION ALL Clause

Sometimes, you might want to run a query using the OR operator with LIKE statements. In this case, using a UNION ALL clause can improve the speed of your query, particularly if the columns on both sides of the OR operator are indexed.

To start, let’s run this query:

SELECT * FROM employees WHERE first_name LIKE 'C%' OR last_name LIKE 'C%';

This query searches for first names or last names that start with “C”. It returned 28,970 rows, taking about 0.20 seconds.

Check using the EXPLAIN command to see how many rows are being scanned!

EXPLAIN SELECT * FROM employees WHERE first_name LIKE 'C%' OR last_name LIKE 'C%';

Once more, we can see that almost all the rows are being scanned, so let’s add indexes to both the first_name and last_name columns.

Try adding an index to both the first_name and last_name columns.

CREATE INDEX first_name_index ON employees(first_name);
CREATE INDEX last_name_index ON employees(last_name);

Great! With your indexes now in place, we can re-run the query:

SELECT * FROM employees WHERE first_name LIKE 'C%' OR last_name LIKE 'C%';

Let’s also see how many rows are being scanned:

EXPLAIN SELECT * FROM employees WHERE first_name LIKE 'C%' OR last_name LIKE 'C%';

With indexes, the query still scans all the rows.

Let’s use the UNION ALL clause to improve the performance of this query.

We can do this with the following:

SELECT * FROM employees WHERE first_name LIKE 'C%' UNION ALL SELECT * FROM employees WHERE last_name LIKE 'C%';

As we can see, this query only takes 0.11 seconds to execute, running faster than when we used the OR operator.

Using the EXPLAIN statement, we can see why that might be

explain SELECT * FROM employees WHERE first_name LIKE 'C%' UNION ALL SELECT * FROM employees WHERE last_name LIKE 'C%';

As the EXPLAIN statement reveals, there were two SELECT operations performed, with the total number of rows scanned sitting at 54,790. This is less than the original query that scanned the entire table and, as a result, the query performs faster.

Please note, if you choose to perform a leading wildcard search with an index, the entire table will still be scanned. You can see this yourself with the following query:

SELECT * FROM employees WHERE first_name LIKE '%C';

With this query, we want to find all the employees whose first names end with “C”.

When checking with the EXPLAIN and SHOW INDEX statements, we can see that although we have an index on first_name, the index is not used and results in a search of the entire table.

Under the EXPLAIN statement’s possible_keys column, we can see that this index has not been used as the entry is NULL.

On the other hand, indexes do work with trailing wildcards, as seen with the following query that finds all employees whose first names begin with “C”:

SELECT * FROM employees WHERE first_name LIKE 'C%';

Under the EXPLAIN statement’s possible_keys and Extra columns, we can see that the first_name_index is used. With only 20,622 rows scanned, the query performs better.

explain SELECT * FROM employees WHERE first_name LIKE 'C%';

Exercise 5: Be SELECTive

In general, it’s best practice to only select the columns that you need. For example, if you wanted to see the names and hire dates of the various employees, you could show that with the following query:

Notice how the query loads 300,024 rows in about 0.26 seconds. With the EXPLAIN statement, we can see that the entire table is being scanned, which makes sense because we are looking at all the entries.

If we, however, only wanted to see the names and hire dates, then we should select those columns:

SELECT first_name, last_name, hire_date FROM employees;

As you can see, this query was executed a little faster despite scanning the entire table as well.